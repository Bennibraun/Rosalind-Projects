[
    {
        "label": "SeqIO",
        "importPath": "Bio",
        "description": "Bio",
        "isExtraImport": true,
        "detail": "Bio",
        "documentation": {}
    },
    {
        "label": "SeqIO",
        "importPath": "Bio",
        "description": "Bio",
        "isExtraImport": true,
        "detail": "Bio",
        "documentation": {}
    },
    {
        "label": "SeqIO",
        "importPath": "Bio",
        "description": "Bio",
        "isExtraImport": true,
        "detail": "Bio",
        "documentation": {}
    },
    {
        "label": "SeqIO",
        "importPath": "Bio",
        "description": "Bio",
        "isExtraImport": true,
        "detail": "Bio",
        "documentation": {}
    },
    {
        "label": "SeqIO",
        "importPath": "Bio",
        "description": "Bio",
        "isExtraImport": true,
        "detail": "Bio",
        "documentation": {}
    },
    {
        "label": "pattern_count",
        "importPath": "BA1A",
        "description": "BA1A",
        "isExtraImport": true,
        "detail": "BA1A",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "nt_count",
        "kind": 5,
        "importPath": "stronghold.1 dna",
        "description": "stronghold.1 dna",
        "peekOfCode": "nt_count = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\nwith open('data/rosalind_dna.txt', 'r') as f:\n    bases = f.readline().strip()\n    # bases = 'AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC'\n    for base in bases:\n        nt_count[base] += 1\nfor key, value in nt_count.items():\n    print(value,end=' ')",
        "detail": "stronghold.1 dna",
        "documentation": {}
    },
    {
        "label": "seqs",
        "kind": 5,
        "importPath": "stronghold.10 cons",
        "description": "stronghold.10 cons",
        "peekOfCode": "seqs = SeqIO.parse(\"data/rosalind_cons.txt\", \"fasta\")\nnt_map = {'A':[],'C':[],'G':[],'T':[]}\nsized = False\nfor seq in seqs:\n    if not sized:\n        for key in nt_map:\n            nt_map[key] = [0] * len(seq.seq)\n        sized = True\n    i = 0\n    for nt in seq.seq:",
        "detail": "stronghold.10 cons",
        "documentation": {}
    },
    {
        "label": "nt_map",
        "kind": 5,
        "importPath": "stronghold.10 cons",
        "description": "stronghold.10 cons",
        "peekOfCode": "nt_map = {'A':[],'C':[],'G':[],'T':[]}\nsized = False\nfor seq in seqs:\n    if not sized:\n        for key in nt_map:\n            nt_map[key] = [0] * len(seq.seq)\n        sized = True\n    i = 0\n    for nt in seq.seq:\n        nt_map[nt][i] += 1",
        "detail": "stronghold.10 cons",
        "documentation": {}
    },
    {
        "label": "sized",
        "kind": 5,
        "importPath": "stronghold.10 cons",
        "description": "stronghold.10 cons",
        "peekOfCode": "sized = False\nfor seq in seqs:\n    if not sized:\n        for key in nt_map:\n            nt_map[key] = [0] * len(seq.seq)\n        sized = True\n    i = 0\n    for nt in seq.seq:\n        nt_map[nt][i] += 1\n        i += 1",
        "detail": "stronghold.10 cons",
        "documentation": {}
    },
    {
        "label": "rabbits",
        "kind": 5,
        "importPath": "stronghold.11 fibd",
        "description": "stronghold.11 fibd",
        "peekOfCode": "rabbits = [0]*m\nrabbits[0] = 1\nfor i in range(n-1):\n    temp = sum(rabbits[1:])\n    rabbits = [temp] + rabbits[:-1]\nprint(sum(rabbits))",
        "detail": "stronghold.11 fibd",
        "documentation": {}
    },
    {
        "label": "rabbits[0]",
        "kind": 5,
        "importPath": "stronghold.11 fibd",
        "description": "stronghold.11 fibd",
        "peekOfCode": "rabbits[0] = 1\nfor i in range(n-1):\n    temp = sum(rabbits[1:])\n    rabbits = [temp] + rabbits[:-1]\nprint(sum(rabbits))",
        "detail": "stronghold.11 fibd",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "stronghold.12 grph",
        "description": "stronghold.12 grph",
        "peekOfCode": "k = 3\nfor s in nodes:\n    suffix = nodes[s][-k:]\n    for t in nodes:\n        if nodes[t] != nodes[s]:\n            prefix = nodes[t][:k]\n            if suffix == prefix:\n                print(s,t)",
        "detail": "stronghold.12 grph",
        "documentation": {}
    },
    {
        "label": "dom_probs",
        "kind": 5,
        "importPath": "stronghold.13 iev",
        "description": "stronghold.13 iev",
        "peekOfCode": "dom_probs = [1,1,1,0.75,0.5,0]\ntotal = sum(genotypes)\nexpected = 0\nfor genotype, dom in zip(genotypes,dom_probs):\n    expected += 2 * genotype * dom\nprint(expected)",
        "detail": "stronghold.13 iev",
        "documentation": {}
    },
    {
        "label": "total",
        "kind": 5,
        "importPath": "stronghold.13 iev",
        "description": "stronghold.13 iev",
        "peekOfCode": "total = sum(genotypes)\nexpected = 0\nfor genotype, dom in zip(genotypes,dom_probs):\n    expected += 2 * genotype * dom\nprint(expected)",
        "detail": "stronghold.13 iev",
        "documentation": {}
    },
    {
        "label": "expected",
        "kind": 5,
        "importPath": "stronghold.13 iev",
        "description": "stronghold.13 iev",
        "peekOfCode": "expected = 0\nfor genotype, dom in zip(genotypes,dom_probs):\n    expected += 2 * genotype * dom\nprint(expected)",
        "detail": "stronghold.13 iev",
        "documentation": {}
    },
    {
        "label": "common_substr",
        "kind": 2,
        "importPath": "stronghold.14 lcsm",
        "description": "stronghold.14 lcsm",
        "peekOfCode": "def common_substr(s, seqs, length):\n    for start in range(len(s)-length):\n        substr = s[start:start+length]\n        i = 0\n        while i < len(seqs) and substr in seqs[i]:\n            i += 1\n        if i == len(seqs):\n            return substr\n    return None\nlongest_seq = max(dna, key=len)",
        "detail": "stronghold.14 lcsm",
        "documentation": {}
    },
    {
        "label": "longest_seq",
        "kind": 5,
        "importPath": "stronghold.14 lcsm",
        "description": "stronghold.14 lcsm",
        "peekOfCode": "longest_seq = max(dna, key=len)\nlength = 1\nwhile True:\n    if new_motif := common_substr(longest_seq, dna, length):\n        motif = new_motif\n    else:\n        break\n    length += 1\nprint(motif)",
        "detail": "stronghold.14 lcsm",
        "documentation": {}
    },
    {
        "label": "length",
        "kind": 5,
        "importPath": "stronghold.14 lcsm",
        "description": "stronghold.14 lcsm",
        "peekOfCode": "length = 1\nwhile True:\n    if new_motif := common_substr(longest_seq, dna, length):\n        motif = new_motif\n    else:\n        break\n    length += 1\nprint(motif)",
        "detail": "stronghold.14 lcsm",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "stronghold.15 lia",
        "description": "stronghold.15 lia",
        "peekOfCode": "k = 2\nN = 1\n# first gen:\n# Aa Bb * Aa Bb\n# AA BB = 1/4 * 1/4 = 1/16\n# AA Bb = 1/4 * 1/2 = 1/8\n# AA bb = 1/4 * 1/4 = 1/16\n# Aa BB = 1/2 * 1/4 = 1/8\n# Aa Bb = 1/2 * 1/2 = 1/4\n# Aa bb = 1/2 * 1/4 = 1/8",
        "detail": "stronghold.15 lia",
        "documentation": {}
    },
    {
        "label": "N",
        "kind": 5,
        "importPath": "stronghold.15 lia",
        "description": "stronghold.15 lia",
        "peekOfCode": "N = 1\n# first gen:\n# Aa Bb * Aa Bb\n# AA BB = 1/4 * 1/4 = 1/16\n# AA Bb = 1/4 * 1/2 = 1/8\n# AA bb = 1/4 * 1/4 = 1/16\n# Aa BB = 1/2 * 1/4 = 1/8\n# Aa Bb = 1/2 * 1/2 = 1/4\n# Aa bb = 1/2 * 1/4 = 1/8\n# aa BB = 1/4 * 1/4 = 1/16",
        "detail": "stronghold.15 lia",
        "documentation": {}
    },
    {
        "label": "mature",
        "kind": 5,
        "importPath": "stronghold.4 fib",
        "description": "stronghold.4 fib",
        "peekOfCode": "mature = 0\nyoung = 1\nfor i in range(n):\n    new_young = mature * k\n    mature += young\n    young = new_young\nprint(mature)",
        "detail": "stronghold.4 fib",
        "documentation": {}
    },
    {
        "label": "young",
        "kind": 5,
        "importPath": "stronghold.4 fib",
        "description": "stronghold.4 fib",
        "peekOfCode": "young = 1\nfor i in range(n):\n    new_young = mature * k\n    mature += young\n    young = new_young\nprint(mature)",
        "detail": "stronghold.4 fib",
        "documentation": {}
    },
    {
        "label": "dna",
        "kind": 5,
        "importPath": "stronghold.5 gc",
        "description": "stronghold.5 gc",
        "peekOfCode": "dna = SeqIO.parse(open('data/rosalind_gc.txt', 'r'), 'fasta')\nhighest_gc = ('',0)\nfor fasta in dna:\n    gc_count = 0\n    for base in fasta.seq:\n        if base == 'G' or base == 'C':\n            gc_count += 1\n    gc_count = (gc_count / len(fasta.seq)) * 100\n    if gc_count > highest_gc[1]:\n        highest_gc = (fasta.id, gc_count)",
        "detail": "stronghold.5 gc",
        "documentation": {}
    },
    {
        "label": "highest_gc",
        "kind": 5,
        "importPath": "stronghold.5 gc",
        "description": "stronghold.5 gc",
        "peekOfCode": "highest_gc = ('',0)\nfor fasta in dna:\n    gc_count = 0\n    for base in fasta.seq:\n        if base == 'G' or base == 'C':\n            gc_count += 1\n    gc_count = (gc_count / len(fasta.seq)) * 100\n    if gc_count > highest_gc[1]:\n        highest_gc = (fasta.id, gc_count)\nprint(highest_gc[0],'\\n'+str(highest_gc[1])[:-8])",
        "detail": "stronghold.5 gc",
        "documentation": {}
    },
    {
        "label": "hamming_distance",
        "kind": 5,
        "importPath": "stronghold.6 hamm",
        "description": "stronghold.6 hamm",
        "peekOfCode": "hamming_distance = 0\nfor i in range(len(s1)):\n    if s1[i] != s2[i]:\n        hamming_distance += 1\nprint(hamming_distance)",
        "detail": "stronghold.6 hamm",
        "documentation": {}
    },
    {
        "label": "pop",
        "kind": 5,
        "importPath": "stronghold.7 iprb",
        "description": "stronghold.7 iprb",
        "peekOfCode": "pop = k+m+n\nprob_dominant = 1 - (m*n + .25*m*(m-1) + n*(n-1)) / (pop*(pop-1))\nprint(prob_dominant)",
        "detail": "stronghold.7 iprb",
        "documentation": {}
    },
    {
        "label": "prob_dominant",
        "kind": 5,
        "importPath": "stronghold.7 iprb",
        "description": "stronghold.7 iprb",
        "peekOfCode": "prob_dominant = 1 - (m*n + .25*m*(m-1) + n*(n-1)) / (pop*(pop-1))\nprint(prob_dominant)",
        "detail": "stronghold.7 iprb",
        "documentation": {}
    },
    {
        "label": "rna_to_prot_map",
        "kind": 5,
        "importPath": "stronghold.8 prot",
        "description": "stronghold.8 prot",
        "peekOfCode": "rna_to_prot_map = {\n    'UUU': 'F', 'CUU': 'L', 'AUU': 'I', 'GUU': 'V',\n    'UUC': 'F', 'CUC': 'L', 'AUC': 'I', 'GUC': 'V',\n    'UUA': 'L', 'CUA': 'L', 'AUA': 'I', 'GUA': 'V',\n    'UUG': 'L', 'CUG': 'L', 'AUG': 'M', 'GUG': 'V',\n    'UCU': 'S', 'CCU': 'P', 'ACU': 'T', 'GCU': 'A',\n    'UCC': 'S', 'CCC': 'P', 'ACC': 'T', 'GCC': 'A',\n    'UCA': 'S', 'CCA': 'P', 'ACA': 'T', 'GCA': 'A',\n    'UCG': 'S', 'CCG': 'P', 'ACG': 'T', 'GCG': 'A',\n    'UAU': 'Y', 'CAU': 'H', 'AAU': 'N', 'GAU': 'D',",
        "detail": "stronghold.8 prot",
        "documentation": {}
    },
    {
        "label": "prot",
        "kind": 5,
        "importPath": "stronghold.8 prot",
        "description": "stronghold.8 prot",
        "peekOfCode": "prot = ''\nfor nt in range(0, len(rna), 3):\n    if rna_to_prot_map[rna[nt:nt+3]] == 'Stop':\n        break\n    prot += rna_to_prot_map[rna[nt:nt+3]]\nprint(prot)",
        "detail": "stronghold.8 prot",
        "documentation": {}
    },
    {
        "label": "locs",
        "kind": 5,
        "importPath": "stronghold.9 subs",
        "description": "stronghold.9 subs",
        "peekOfCode": "locs = []\nfor i in range(len(s)-len(t)+1):\n    if s[i:i+len(t)] == t:\n        locs.append(str(i+1))\nprint(' '.join(locs))",
        "detail": "stronghold.9 subs",
        "documentation": {}
    },
    {
        "label": "pattern_count",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1A",
        "description": "textbook.scripts.1.BA1A",
        "peekOfCode": "def pattern_count(text,pattern):\n\tcount = 0\n\tfor i in range(len(text)-len(pattern)+1):\n\t\tif text[i:i+len(pattern)] == pattern:\n\t\t\tcount += 1\n\treturn count\nif __name__ == '__main__':\n\timport os\n\timport glob\n\tdatapath = []",
        "detail": "textbook.scripts.1.BA1A",
        "documentation": {}
    },
    {
        "label": "\tcount",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1A",
        "description": "textbook.scripts.1.BA1A",
        "peekOfCode": "\tcount = 0\n\tfor i in range(len(text)-len(pattern)+1):\n\t\tif text[i:i+len(pattern)] == pattern:\n\t\t\tcount += 1\n\treturn count\nif __name__ == '__main__':\n\timport os\n\timport glob\n\tdatapath = []\n\tif 'textbook' in glob.glob('*'):",
        "detail": "textbook.scripts.1.BA1A",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1A",
        "description": "textbook.scripts.1.BA1A",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.append('..')\n\t\tdatapath.append('data')\n\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1a.txt')) as f:\n\t\t# read data",
        "detail": "textbook.scripts.1.BA1A",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1A",
        "description": "textbook.scripts.1.BA1A",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1a.txt')) as f:\n\t\t# read data\n\t\ttext = f.readline().strip()\n\t\tpattern = f.readline().strip()\n\tprint(pattern_count(text,pattern))",
        "detail": "textbook.scripts.1.BA1A",
        "documentation": {}
    },
    {
        "label": "\t\ttext",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1A",
        "description": "textbook.scripts.1.BA1A",
        "peekOfCode": "\t\ttext = f.readline().strip()\n\t\tpattern = f.readline().strip()\n\tprint(pattern_count(text,pattern))",
        "detail": "textbook.scripts.1.BA1A",
        "documentation": {}
    },
    {
        "label": "\t\tpattern",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1A",
        "description": "textbook.scripts.1.BA1A",
        "peekOfCode": "\t\tpattern = f.readline().strip()\n\tprint(pattern_count(text,pattern))",
        "detail": "textbook.scripts.1.BA1A",
        "documentation": {}
    },
    {
        "label": "frequent_words",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1B",
        "description": "textbook.scripts.1.BA1B",
        "peekOfCode": "def frequent_words(text,k):\n\tfrequent_patterns = set()\n\tcount = {}\n\tfor i in range(len(text) - k + 1):\n\t\tpattern = text[i:i+k]\n\t\tcount[i] = pattern_count(text,pattern)\n\tmax_count = max(count.values())\n\tfor i in range(len(text) - k + 1):\n\t\tif count[i] == max_count:\n\t\t\tfrequent_patterns.add(text[i:i+k])",
        "detail": "textbook.scripts.1.BA1B",
        "documentation": {}
    },
    {
        "label": "\tfrequent_patterns",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1B",
        "description": "textbook.scripts.1.BA1B",
        "peekOfCode": "\tfrequent_patterns = set()\n\tcount = {}\n\tfor i in range(len(text) - k + 1):\n\t\tpattern = text[i:i+k]\n\t\tcount[i] = pattern_count(text,pattern)\n\tmax_count = max(count.values())\n\tfor i in range(len(text) - k + 1):\n\t\tif count[i] == max_count:\n\t\t\tfrequent_patterns.add(text[i:i+k])\n\treturn frequent_patterns",
        "detail": "textbook.scripts.1.BA1B",
        "documentation": {}
    },
    {
        "label": "\tcount",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1B",
        "description": "textbook.scripts.1.BA1B",
        "peekOfCode": "\tcount = {}\n\tfor i in range(len(text) - k + 1):\n\t\tpattern = text[i:i+k]\n\t\tcount[i] = pattern_count(text,pattern)\n\tmax_count = max(count.values())\n\tfor i in range(len(text) - k + 1):\n\t\tif count[i] == max_count:\n\t\t\tfrequent_patterns.add(text[i:i+k])\n\treturn frequent_patterns\nif __name__ == '__main__':",
        "detail": "textbook.scripts.1.BA1B",
        "documentation": {}
    },
    {
        "label": "\t\tpattern",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1B",
        "description": "textbook.scripts.1.BA1B",
        "peekOfCode": "\t\tpattern = text[i:i+k]\n\t\tcount[i] = pattern_count(text,pattern)\n\tmax_count = max(count.values())\n\tfor i in range(len(text) - k + 1):\n\t\tif count[i] == max_count:\n\t\t\tfrequent_patterns.add(text[i:i+k])\n\treturn frequent_patterns\nif __name__ == '__main__':\n\timport os\n\timport glob",
        "detail": "textbook.scripts.1.BA1B",
        "documentation": {}
    },
    {
        "label": "\t\tcount[i]",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1B",
        "description": "textbook.scripts.1.BA1B",
        "peekOfCode": "\t\tcount[i] = pattern_count(text,pattern)\n\tmax_count = max(count.values())\n\tfor i in range(len(text) - k + 1):\n\t\tif count[i] == max_count:\n\t\t\tfrequent_patterns.add(text[i:i+k])\n\treturn frequent_patterns\nif __name__ == '__main__':\n\timport os\n\timport glob\n\tdatapath = []",
        "detail": "textbook.scripts.1.BA1B",
        "documentation": {}
    },
    {
        "label": "\tmax_count",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1B",
        "description": "textbook.scripts.1.BA1B",
        "peekOfCode": "\tmax_count = max(count.values())\n\tfor i in range(len(text) - k + 1):\n\t\tif count[i] == max_count:\n\t\t\tfrequent_patterns.add(text[i:i+k])\n\treturn frequent_patterns\nif __name__ == '__main__':\n\timport os\n\timport glob\n\tdatapath = []\n\tif 'textbook' in glob.glob('*'):",
        "detail": "textbook.scripts.1.BA1B",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1B",
        "description": "textbook.scripts.1.BA1B",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.append('..')\n\t\tdatapath.append('data')\n\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1b.txt')) as f:\n\t\t# read data",
        "detail": "textbook.scripts.1.BA1B",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1B",
        "description": "textbook.scripts.1.BA1B",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1b.txt')) as f:\n\t\t# read data\n\t\ttext = f.readline().strip()\n\t\tk = int(f.readline().strip())\n\tresult = frequent_words(text,k)\n\tprint(' '.join(result))",
        "detail": "textbook.scripts.1.BA1B",
        "documentation": {}
    },
    {
        "label": "\t\ttext",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1B",
        "description": "textbook.scripts.1.BA1B",
        "peekOfCode": "\t\ttext = f.readline().strip()\n\t\tk = int(f.readline().strip())\n\tresult = frequent_words(text,k)\n\tprint(' '.join(result))",
        "detail": "textbook.scripts.1.BA1B",
        "documentation": {}
    },
    {
        "label": "\t\tk",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1B",
        "description": "textbook.scripts.1.BA1B",
        "peekOfCode": "\t\tk = int(f.readline().strip())\n\tresult = frequent_words(text,k)\n\tprint(' '.join(result))",
        "detail": "textbook.scripts.1.BA1B",
        "documentation": {}
    },
    {
        "label": "\tresult",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1B",
        "description": "textbook.scripts.1.BA1B",
        "peekOfCode": "\tresult = frequent_words(text,k)\n\tprint(' '.join(result))",
        "detail": "textbook.scripts.1.BA1B",
        "documentation": {}
    },
    {
        "label": "revc",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1C",
        "description": "textbook.scripts.1.BA1C",
        "peekOfCode": "def revc(dna):\n\treturn ''.join([{'A':'T','T':'A','C':'G','G':'C'}[i] for i in dna])[::-1]\nprint(revc(dna))",
        "detail": "textbook.scripts.1.BA1C",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1C",
        "description": "textbook.scripts.1.BA1C",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.append('..')\n\t\tdatapath.append('data')\n\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1c.txt')) as f:\n\t\t# read data",
        "detail": "textbook.scripts.1.BA1C",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1C",
        "description": "textbook.scripts.1.BA1C",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1c.txt')) as f:\n\t\t# read data\n\t\tdna = f.readline().strip()\ndef revc(dna):\n\treturn ''.join([{'A':'T','T':'A','C':'G','G':'C'}[i] for i in dna])[::-1]\nprint(revc(dna))",
        "detail": "textbook.scripts.1.BA1C",
        "documentation": {}
    },
    {
        "label": "\t\tdna",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1C",
        "description": "textbook.scripts.1.BA1C",
        "peekOfCode": "\t\tdna = f.readline().strip()\ndef revc(dna):\n\treturn ''.join([{'A':'T','T':'A','C':'G','G':'C'}[i] for i in dna])[::-1]\nprint(revc(dna))",
        "detail": "textbook.scripts.1.BA1C",
        "documentation": {}
    },
    {
        "label": "pattern_match",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1D",
        "description": "textbook.scripts.1.BA1D",
        "peekOfCode": "def pattern_match(pattern,genome):\n\tpositions = []\n\tfor i in range(len(genome)-len(pattern)+1):\n\t\tif genome[i:i+len(pattern)] == pattern:\n\t\t\tpositions.append(i)\n\treturn positions\nprint(' '.join([str(x) for x in pattern_match(pattern,genome)]))",
        "detail": "textbook.scripts.1.BA1D",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1D",
        "description": "textbook.scripts.1.BA1D",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.append('..')\n\t\tdatapath.append('data')\n\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1d.txt')) as f:\n\t\t# read data",
        "detail": "textbook.scripts.1.BA1D",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1D",
        "description": "textbook.scripts.1.BA1D",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1d.txt')) as f:\n\t\t# read data\n\t\tpattern = f.readline().strip()\n\t\tgenome = f.readline().strip()\ndef pattern_match(pattern,genome):\n\tpositions = []\n\tfor i in range(len(genome)-len(pattern)+1):\n\t\tif genome[i:i+len(pattern)] == pattern:\n\t\t\tpositions.append(i)",
        "detail": "textbook.scripts.1.BA1D",
        "documentation": {}
    },
    {
        "label": "\t\tpattern",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1D",
        "description": "textbook.scripts.1.BA1D",
        "peekOfCode": "\t\tpattern = f.readline().strip()\n\t\tgenome = f.readline().strip()\ndef pattern_match(pattern,genome):\n\tpositions = []\n\tfor i in range(len(genome)-len(pattern)+1):\n\t\tif genome[i:i+len(pattern)] == pattern:\n\t\t\tpositions.append(i)\n\treturn positions\nprint(' '.join([str(x) for x in pattern_match(pattern,genome)]))",
        "detail": "textbook.scripts.1.BA1D",
        "documentation": {}
    },
    {
        "label": "\t\tgenome",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1D",
        "description": "textbook.scripts.1.BA1D",
        "peekOfCode": "\t\tgenome = f.readline().strip()\ndef pattern_match(pattern,genome):\n\tpositions = []\n\tfor i in range(len(genome)-len(pattern)+1):\n\t\tif genome[i:i+len(pattern)] == pattern:\n\t\t\tpositions.append(i)\n\treturn positions\nprint(' '.join([str(x) for x in pattern_match(pattern,genome)]))",
        "detail": "textbook.scripts.1.BA1D",
        "documentation": {}
    },
    {
        "label": "\tpositions",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1D",
        "description": "textbook.scripts.1.BA1D",
        "peekOfCode": "\tpositions = []\n\tfor i in range(len(genome)-len(pattern)+1):\n\t\tif genome[i:i+len(pattern)] == pattern:\n\t\t\tpositions.append(i)\n\treturn positions\nprint(' '.join([str(x) for x in pattern_match(pattern,genome)]))",
        "detail": "textbook.scripts.1.BA1D",
        "documentation": {}
    },
    {
        "label": "symbol_to_number",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "def symbol_to_number(symbol):\n\treturn {'A':0,'C':1,'G':2,'T':3}[symbol]\ndef pattern_to_number(pattern):\n\tif len(pattern) == 0:\n\t\treturn 0\n\tsymbol = pattern[-1]\n\tprefix = pattern[:-1]\n\treturn 4*pattern_to_number(prefix) + symbol_to_number(symbol)\ndef number_to_symbol(number):\n\treturn {0:'A',1:'C',2:'G',3:'T'}[number]",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "pattern_to_number",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "def pattern_to_number(pattern):\n\tif len(pattern) == 0:\n\t\treturn 0\n\tsymbol = pattern[-1]\n\tprefix = pattern[:-1]\n\treturn 4*pattern_to_number(prefix) + symbol_to_number(symbol)\ndef number_to_symbol(number):\n\treturn {0:'A',1:'C',2:'G',3:'T'}[number]\ndef number_to_pattern(index,k):\n\tif k == 1:",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "number_to_symbol",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "def number_to_symbol(number):\n\treturn {0:'A',1:'C',2:'G',3:'T'}[number]\ndef number_to_pattern(index,k):\n\tif k == 1:\n\t\treturn number_to_symbol(index)\n\tprefix_index = index // 4\n\tr = index % 4\n\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "number_to_pattern",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "def number_to_pattern(index,k):\n\tif k == 1:\n\t\treturn number_to_symbol(index)\n\tprefix_index = index // 4\n\tr = index % 4\n\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\ndef find_frequent_words(genome,k):\n\tkmers = []",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "find_frequent_words",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "def find_frequent_words(genome,k):\n\tkmers = []\n\tfor i in range(len(genome)-k+1):\n\t\tpattern_num = pattern_to_number(genome[i:i+k])\n\t\tkmers.append(pattern_num)\n\tkmers.sort()\n\tfreqs= {}\n\tfor kmer in kmers:\n\t\tif kmer in freqs:\n\t\t\tfreqs[kmer] += 1",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "find_clumps",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "def find_clumps(genome,k,L,t):\n\tfreq_patterns = set()\n\tfreqs = find_frequent_words(genome[:L],k)\n\tfor i in range(len(genome)-L):\n\t\ttext = genome[i:i+L]\n\t\tfor kmer in freqs:\n\t\t\tif freqs[kmer] >= t:\n\t\t\t\tfreq_patterns.add(number_to_pattern(kmer,k))\n\t\t# remove first kmer\n\t\tfirst_kmer = pattern_to_number(text[:k])",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.append('..')\n\t\tdatapath.append('data')\n\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1e.txt')) as f:\n\t\t# read data",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1e.txt')) as f:\n\t\t# read data\n\t\tgenome = f.readline().strip()\n\t\tk, L, t = [int(x) for x in f.readline().strip().split(' ')]\ndef symbol_to_number(symbol):\n\treturn {'A':0,'C':1,'G':2,'T':3}[symbol]\ndef pattern_to_number(pattern):\n\tif len(pattern) == 0:\n\t\treturn 0",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "\t\tgenome",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "\t\tgenome = f.readline().strip()\n\t\tk, L, t = [int(x) for x in f.readline().strip().split(' ')]\ndef symbol_to_number(symbol):\n\treturn {'A':0,'C':1,'G':2,'T':3}[symbol]\ndef pattern_to_number(pattern):\n\tif len(pattern) == 0:\n\t\treturn 0\n\tsymbol = pattern[-1]\n\tprefix = pattern[:-1]\n\treturn 4*pattern_to_number(prefix) + symbol_to_number(symbol)",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "\tsymbol",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "\tsymbol = pattern[-1]\n\tprefix = pattern[:-1]\n\treturn 4*pattern_to_number(prefix) + symbol_to_number(symbol)\ndef number_to_symbol(number):\n\treturn {0:'A',1:'C',2:'G',3:'T'}[number]\ndef number_to_pattern(index,k):\n\tif k == 1:\n\t\treturn number_to_symbol(index)\n\tprefix_index = index // 4\n\tr = index % 4",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "\tprefix",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "\tprefix = pattern[:-1]\n\treturn 4*pattern_to_number(prefix) + symbol_to_number(symbol)\ndef number_to_symbol(number):\n\treturn {0:'A',1:'C',2:'G',3:'T'}[number]\ndef number_to_pattern(index,k):\n\tif k == 1:\n\t\treturn number_to_symbol(index)\n\tprefix_index = index // 4\n\tr = index % 4\n\tsymbol = number_to_symbol(r)",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "\tprefix_index",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "\tprefix_index = index // 4\n\tr = index % 4\n\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\ndef find_frequent_words(genome,k):\n\tkmers = []\n\tfor i in range(len(genome)-k+1):\n\t\tpattern_num = pattern_to_number(genome[i:i+k])\n\t\tkmers.append(pattern_num)",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "\tr",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "\tr = index % 4\n\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\ndef find_frequent_words(genome,k):\n\tkmers = []\n\tfor i in range(len(genome)-k+1):\n\t\tpattern_num = pattern_to_number(genome[i:i+k])\n\t\tkmers.append(pattern_num)\n\tkmers.sort()",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "\tsymbol",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\ndef find_frequent_words(genome,k):\n\tkmers = []\n\tfor i in range(len(genome)-k+1):\n\t\tpattern_num = pattern_to_number(genome[i:i+k])\n\t\tkmers.append(pattern_num)\n\tkmers.sort()\n\tfreqs= {}",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "\tprefix_pattern",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\ndef find_frequent_words(genome,k):\n\tkmers = []\n\tfor i in range(len(genome)-k+1):\n\t\tpattern_num = pattern_to_number(genome[i:i+k])\n\t\tkmers.append(pattern_num)\n\tkmers.sort()\n\tfreqs= {}\n\tfor kmer in kmers:",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "\tkmers",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "\tkmers = []\n\tfor i in range(len(genome)-k+1):\n\t\tpattern_num = pattern_to_number(genome[i:i+k])\n\t\tkmers.append(pattern_num)\n\tkmers.sort()\n\tfreqs= {}\n\tfor kmer in kmers:\n\t\tif kmer in freqs:\n\t\t\tfreqs[kmer] += 1\n\t\telse:",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "\t\tpattern_num",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "\t\tpattern_num = pattern_to_number(genome[i:i+k])\n\t\tkmers.append(pattern_num)\n\tkmers.sort()\n\tfreqs= {}\n\tfor kmer in kmers:\n\t\tif kmer in freqs:\n\t\t\tfreqs[kmer] += 1\n\t\telse:\n\t\t\tfreqs[kmer] = 1\n\treturn freqs",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "\t\t\tfreqs[kmer]",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "\t\t\tfreqs[kmer] = 1\n\treturn freqs\ndef find_clumps(genome,k,L,t):\n\tfreq_patterns = set()\n\tfreqs = find_frequent_words(genome[:L],k)\n\tfor i in range(len(genome)-L):\n\t\ttext = genome[i:i+L]\n\t\tfor kmer in freqs:\n\t\t\tif freqs[kmer] >= t:\n\t\t\t\tfreq_patterns.add(number_to_pattern(kmer,k))",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "\tfreq_patterns",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "\tfreq_patterns = set()\n\tfreqs = find_frequent_words(genome[:L],k)\n\tfor i in range(len(genome)-L):\n\t\ttext = genome[i:i+L]\n\t\tfor kmer in freqs:\n\t\t\tif freqs[kmer] >= t:\n\t\t\t\tfreq_patterns.add(number_to_pattern(kmer,k))\n\t\t# remove first kmer\n\t\tfirst_kmer = pattern_to_number(text[:k])\n\t\tfreqs[first_kmer] -= 1",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "\tfreqs",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "\tfreqs = find_frequent_words(genome[:L],k)\n\tfor i in range(len(genome)-L):\n\t\ttext = genome[i:i+L]\n\t\tfor kmer in freqs:\n\t\t\tif freqs[kmer] >= t:\n\t\t\t\tfreq_patterns.add(number_to_pattern(kmer,k))\n\t\t# remove first kmer\n\t\tfirst_kmer = pattern_to_number(text[:k])\n\t\tfreqs[first_kmer] -= 1\n\t\t# add last kmer",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "\t\ttext",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "\t\ttext = genome[i:i+L]\n\t\tfor kmer in freqs:\n\t\t\tif freqs[kmer] >= t:\n\t\t\t\tfreq_patterns.add(number_to_pattern(kmer,k))\n\t\t# remove first kmer\n\t\tfirst_kmer = pattern_to_number(text[:k])\n\t\tfreqs[first_kmer] -= 1\n\t\t# add last kmer\n\t\tlast_kmer = pattern_to_number(text[-k:])\n\t\tif last_kmer in freqs:",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "\t\tfirst_kmer",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "\t\tfirst_kmer = pattern_to_number(text[:k])\n\t\tfreqs[first_kmer] -= 1\n\t\t# add last kmer\n\t\tlast_kmer = pattern_to_number(text[-k:])\n\t\tif last_kmer in freqs:\n\t\t\tfreqs[last_kmer] += 1\n\t\telse:\n\t\t\tfreqs[last_kmer] = 1\n\treturn freq_patterns\n# genome = 'CGGACTCGACAGATGTGAAGAAATGTGAAGACTGAGTGAAGAGAAGAGGAAACACGACACGACATTGCGACATAATGTACGAATGTAATGTGCCTATGGC'",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "\t\tlast_kmer",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "\t\tlast_kmer = pattern_to_number(text[-k:])\n\t\tif last_kmer in freqs:\n\t\t\tfreqs[last_kmer] += 1\n\t\telse:\n\t\t\tfreqs[last_kmer] = 1\n\treturn freq_patterns\n# genome = 'CGGACTCGACAGATGTGAAGAAATGTGAAGACTGAGTGAAGAGAAGAGGAAACACGACACGACATTGCGACATAATGTACGAATGTAATGTGCCTATGGC'\n# k, L, t = [int(x) for x in '5 75 4'.split(' ')]\nprint(' '.join(find_clumps(genome,k,L,t)))",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "\t\t\tfreqs[last_kmer]",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1E",
        "description": "textbook.scripts.1.BA1E",
        "peekOfCode": "\t\t\tfreqs[last_kmer] = 1\n\treturn freq_patterns\n# genome = 'CGGACTCGACAGATGTGAAGAAATGTGAAGACTGAGTGAAGAGAAGAGGAAACACGACACGACATTGCGACATAATGTACGAATGTAATGTGCCTATGGC'\n# k, L, t = [int(x) for x in '5 75 4'.split(' ')]\nprint(' '.join(find_clumps(genome,k,L,t)))",
        "detail": "textbook.scripts.1.BA1E",
        "documentation": {}
    },
    {
        "label": "minimum_gc_skew",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1F",
        "description": "textbook.scripts.1.BA1F",
        "peekOfCode": "def minimum_gc_skew(genome):\n\tskew = 0\n\tmins = {'min':0,'indices':[]}\n\tfor i,nuc in enumerate(genome):\n\t\tskew += {'G':1,'C':-1,'A':0,'T':0}[nuc]\n\t\tif skew < mins['min']:\n\t\t\tmins['min'] = skew\n\t\t\tmins['indices'] = [i+1]\n\t\telif skew == mins['min']:\n\t\t\tmins['indices'].append(i+1)",
        "detail": "textbook.scripts.1.BA1F",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1F",
        "description": "textbook.scripts.1.BA1F",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.append('..')\n\t\tdatapath.append('data')\n\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1f.txt')) as f:\n\t\t# read data",
        "detail": "textbook.scripts.1.BA1F",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1F",
        "description": "textbook.scripts.1.BA1F",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1f.txt')) as f:\n\t\t# read data\n\t\tgenome = f.readline().strip()\ndef minimum_gc_skew(genome):\n\tskew = 0\n\tmins = {'min':0,'indices':[]}\n\tfor i,nuc in enumerate(genome):\n\t\tskew += {'G':1,'C':-1,'A':0,'T':0}[nuc]\n\t\tif skew < mins['min']:",
        "detail": "textbook.scripts.1.BA1F",
        "documentation": {}
    },
    {
        "label": "\t\tgenome",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1F",
        "description": "textbook.scripts.1.BA1F",
        "peekOfCode": "\t\tgenome = f.readline().strip()\ndef minimum_gc_skew(genome):\n\tskew = 0\n\tmins = {'min':0,'indices':[]}\n\tfor i,nuc in enumerate(genome):\n\t\tskew += {'G':1,'C':-1,'A':0,'T':0}[nuc]\n\t\tif skew < mins['min']:\n\t\t\tmins['min'] = skew\n\t\t\tmins['indices'] = [i+1]\n\t\telif skew == mins['min']:",
        "detail": "textbook.scripts.1.BA1F",
        "documentation": {}
    },
    {
        "label": "\tskew",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1F",
        "description": "textbook.scripts.1.BA1F",
        "peekOfCode": "\tskew = 0\n\tmins = {'min':0,'indices':[]}\n\tfor i,nuc in enumerate(genome):\n\t\tskew += {'G':1,'C':-1,'A':0,'T':0}[nuc]\n\t\tif skew < mins['min']:\n\t\t\tmins['min'] = skew\n\t\t\tmins['indices'] = [i+1]\n\t\telif skew == mins['min']:\n\t\t\tmins['indices'].append(i+1)\n\tprint(mins)",
        "detail": "textbook.scripts.1.BA1F",
        "documentation": {}
    },
    {
        "label": "\tmins",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1F",
        "description": "textbook.scripts.1.BA1F",
        "peekOfCode": "\tmins = {'min':0,'indices':[]}\n\tfor i,nuc in enumerate(genome):\n\t\tskew += {'G':1,'C':-1,'A':0,'T':0}[nuc]\n\t\tif skew < mins['min']:\n\t\t\tmins['min'] = skew\n\t\t\tmins['indices'] = [i+1]\n\t\telif skew == mins['min']:\n\t\t\tmins['indices'].append(i+1)\n\tprint(mins)\n\treturn mins['indices']",
        "detail": "textbook.scripts.1.BA1F",
        "documentation": {}
    },
    {
        "label": "\t\t\tmins['min']",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1F",
        "description": "textbook.scripts.1.BA1F",
        "peekOfCode": "\t\t\tmins['min'] = skew\n\t\t\tmins['indices'] = [i+1]\n\t\telif skew == mins['min']:\n\t\t\tmins['indices'].append(i+1)\n\tprint(mins)\n\treturn mins['indices']\n# genome='CCTATCGGTGGATTAGCATGTCCCTGTACGTTTCGCCGCGAACTAGTTCACACGGCTTGATGGCAAATGGTTTTTCCGGCGACCGTAATCGTCCACCGAG'\nprint(' '.join([str(x) for x in minimum_gc_skew(genome)]))",
        "detail": "textbook.scripts.1.BA1F",
        "documentation": {}
    },
    {
        "label": "\t\t\tmins['indices']",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1F",
        "description": "textbook.scripts.1.BA1F",
        "peekOfCode": "\t\t\tmins['indices'] = [i+1]\n\t\telif skew == mins['min']:\n\t\t\tmins['indices'].append(i+1)\n\tprint(mins)\n\treturn mins['indices']\n# genome='CCTATCGGTGGATTAGCATGTCCCTGTACGTTTCGCCGCGAACTAGTTCACACGGCTTGATGGCAAATGGTTTTTCCGGCGACCGTAATCGTCCACCGAG'\nprint(' '.join([str(x) for x in minimum_gc_skew(genome)]))",
        "detail": "textbook.scripts.1.BA1F",
        "documentation": {}
    },
    {
        "label": "hamming_distance",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1G",
        "description": "textbook.scripts.1.BA1G",
        "peekOfCode": "def hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\n# p = 'GGGCCGTTGGT'\n# q = 'GGACCGTTGAC'\nprint(hamming_distance(p,q))",
        "detail": "textbook.scripts.1.BA1G",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1G",
        "description": "textbook.scripts.1.BA1G",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.append('..')\n\t\tdatapath.append('data')\n\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1g.txt')) as f:\n\t\t# read data",
        "detail": "textbook.scripts.1.BA1G",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1G",
        "description": "textbook.scripts.1.BA1G",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1g.txt')) as f:\n\t\t# read data\n\t\tp = f.readline().strip()\n\t\tq = f.readline().strip()\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1",
        "detail": "textbook.scripts.1.BA1G",
        "documentation": {}
    },
    {
        "label": "\t\tp",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1G",
        "description": "textbook.scripts.1.BA1G",
        "peekOfCode": "\t\tp = f.readline().strip()\n\t\tq = f.readline().strip()\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\n# p = 'GGGCCGTTGGT'\n# q = 'GGACCGTTGAC'",
        "detail": "textbook.scripts.1.BA1G",
        "documentation": {}
    },
    {
        "label": "\t\tq",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1G",
        "description": "textbook.scripts.1.BA1G",
        "peekOfCode": "\t\tq = f.readline().strip()\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\n# p = 'GGGCCGTTGGT'\n# q = 'GGACCGTTGAC'\nprint(hamming_distance(p,q))",
        "detail": "textbook.scripts.1.BA1G",
        "documentation": {}
    },
    {
        "label": "\thamming",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1G",
        "description": "textbook.scripts.1.BA1G",
        "peekOfCode": "\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\n# p = 'GGGCCGTTGGT'\n# q = 'GGACCGTTGAC'\nprint(hamming_distance(p,q))",
        "detail": "textbook.scripts.1.BA1G",
        "documentation": {}
    },
    {
        "label": "hamming_distance",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1H",
        "description": "textbook.scripts.1.BA1H",
        "peekOfCode": "def hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef approximate_pattern_matching(pattern,genome,d):\n\tpositions = []\n\tfor i in range(len(genome)-len(pattern)+1):\n\t\tif hamming_distance(genome[i:i+len(pattern)],pattern) <= d:",
        "detail": "textbook.scripts.1.BA1H",
        "documentation": {}
    },
    {
        "label": "approximate_pattern_matching",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1H",
        "description": "textbook.scripts.1.BA1H",
        "peekOfCode": "def approximate_pattern_matching(pattern,genome,d):\n\tpositions = []\n\tfor i in range(len(genome)-len(pattern)+1):\n\t\tif hamming_distance(genome[i:i+len(pattern)],pattern) <= d:\n\t\t\tpositions.append(i)\n\treturn positions\nprint(' '.join([str(x) for x in approximate_pattern_matching(pattern,genome,d)]))",
        "detail": "textbook.scripts.1.BA1H",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1H",
        "description": "textbook.scripts.1.BA1H",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.append('..')\n\t\tdatapath.append('data')\n\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1h.txt')) as f:\n\t\t# read data",
        "detail": "textbook.scripts.1.BA1H",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1H",
        "description": "textbook.scripts.1.BA1H",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1h.txt')) as f:\n\t\t# read data\n\t\tpattern = f.readline().strip()\n\t\tgenome = f.readline().strip()\n\t\td = int(f.readline().strip())\n# pattern = 'ATTCTGGA'\n# genome = 'CGCCCGAATCCAGAACGCATTCCCATATTTCGGGACCACTGGCCTCCACGGTACGGACGTCAATCAAATGCCTAGCGGCTTGTGGTTTCTCCTACGCTCC'\n# d = 3\ndef hamming_distance(p,q):",
        "detail": "textbook.scripts.1.BA1H",
        "documentation": {}
    },
    {
        "label": "\t\tpattern",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1H",
        "description": "textbook.scripts.1.BA1H",
        "peekOfCode": "\t\tpattern = f.readline().strip()\n\t\tgenome = f.readline().strip()\n\t\td = int(f.readline().strip())\n# pattern = 'ATTCTGGA'\n# genome = 'CGCCCGAATCCAGAACGCATTCCCATATTTCGGGACCACTGGCCTCCACGGTACGGACGTCAATCAAATGCCTAGCGGCTTGTGGTTTCTCCTACGCTCC'\n# d = 3\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:",
        "detail": "textbook.scripts.1.BA1H",
        "documentation": {}
    },
    {
        "label": "\t\tgenome",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1H",
        "description": "textbook.scripts.1.BA1H",
        "peekOfCode": "\t\tgenome = f.readline().strip()\n\t\td = int(f.readline().strip())\n# pattern = 'ATTCTGGA'\n# genome = 'CGCCCGAATCCAGAACGCATTCCCATATTTCGGGACCACTGGCCTCCACGGTACGGACGTCAATCAAATGCCTAGCGGCTTGTGGTTTCTCCTACGCTCC'\n# d = 3\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1",
        "detail": "textbook.scripts.1.BA1H",
        "documentation": {}
    },
    {
        "label": "\t\td",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1H",
        "description": "textbook.scripts.1.BA1H",
        "peekOfCode": "\t\td = int(f.readline().strip())\n# pattern = 'ATTCTGGA'\n# genome = 'CGCCCGAATCCAGAACGCATTCCCATATTTCGGGACCACTGGCCTCCACGGTACGGACGTCAATCAAATGCCTAGCGGCTTGTGGTTTCTCCTACGCTCC'\n# d = 3\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming",
        "detail": "textbook.scripts.1.BA1H",
        "documentation": {}
    },
    {
        "label": "\thamming",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1H",
        "description": "textbook.scripts.1.BA1H",
        "peekOfCode": "\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef approximate_pattern_matching(pattern,genome,d):\n\tpositions = []\n\tfor i in range(len(genome)-len(pattern)+1):\n\t\tif hamming_distance(genome[i:i+len(pattern)],pattern) <= d:\n\t\t\tpositions.append(i)",
        "detail": "textbook.scripts.1.BA1H",
        "documentation": {}
    },
    {
        "label": "\tpositions",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1H",
        "description": "textbook.scripts.1.BA1H",
        "peekOfCode": "\tpositions = []\n\tfor i in range(len(genome)-len(pattern)+1):\n\t\tif hamming_distance(genome[i:i+len(pattern)],pattern) <= d:\n\t\t\tpositions.append(i)\n\treturn positions\nprint(' '.join([str(x) for x in approximate_pattern_matching(pattern,genome,d)]))",
        "detail": "textbook.scripts.1.BA1H",
        "documentation": {}
    },
    {
        "label": "hamming_distance",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1I",
        "description": "textbook.scripts.1.BA1I",
        "peekOfCode": "def hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef immediate_neighbors(pattern):\n\tneighborhood = set()\n\tfor i in range(len(pattern)):\n\t\tsymbol = pattern[i]",
        "detail": "textbook.scripts.1.BA1I",
        "documentation": {}
    },
    {
        "label": "immediate_neighbors",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1I",
        "description": "textbook.scripts.1.BA1I",
        "peekOfCode": "def immediate_neighbors(pattern):\n\tneighborhood = set()\n\tfor i in range(len(pattern)):\n\t\tsymbol = pattern[i]\n\t\tfor x in 'ACGT':\n\t\t\tneighborhood.add(pattern[:i]+x+pattern[i+1:])\n\treturn neighborhood\ndef neighbors(pattern,d):\n\tif d == 0:\n\t\treturn {pattern}",
        "detail": "textbook.scripts.1.BA1I",
        "documentation": {}
    },
    {
        "label": "neighbors",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1I",
        "description": "textbook.scripts.1.BA1I",
        "peekOfCode": "def neighbors(pattern,d):\n\tif d == 0:\n\t\treturn {pattern}\n\tif len(pattern) == 1:\n\t\treturn {'A','C','G','T'}\n\tneighborhood = set()\n\tsuffix_neighbors = neighbors(pattern[1:],d)\n\tfor text in suffix_neighbors:\n\t\tif hamming_distance(pattern[1:],text) < d:\n\t\t\tfor x in 'ACGT':",
        "detail": "textbook.scripts.1.BA1I",
        "documentation": {}
    },
    {
        "label": "find_frequent_words_with_mismatches",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1I",
        "description": "textbook.scripts.1.BA1I",
        "peekOfCode": "def find_frequent_words_with_mismatches(genome,k,d):\n\tkmers = []\n\tfor i in range(len(genome)-k+1):\n\t\tpattern = genome[i:i+k]\n\t\tkmers.extend(neighbors(pattern,d))\n\tfreqs= {}\n\tfor kmer in kmers:\n\t\tif kmer in freqs:\n\t\t\tfreqs[kmer] += 1\n\t\telse:",
        "detail": "textbook.scripts.1.BA1I",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1I",
        "description": "textbook.scripts.1.BA1I",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.append('..')\n\t\tdatapath.append('data')\n\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1i.txt')) as f:\n\t\t# read data",
        "detail": "textbook.scripts.1.BA1I",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1I",
        "description": "textbook.scripts.1.BA1I",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1i.txt')) as f:\n\t\t# read data\n\t\tgenome = f.readline().strip()\n\t\tk,d = [int(x) for x in f.readline().strip().split()]\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1",
        "detail": "textbook.scripts.1.BA1I",
        "documentation": {}
    },
    {
        "label": "\t\tgenome",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1I",
        "description": "textbook.scripts.1.BA1I",
        "peekOfCode": "\t\tgenome = f.readline().strip()\n\t\tk,d = [int(x) for x in f.readline().strip().split()]\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef immediate_neighbors(pattern):\n\tneighborhood = set()",
        "detail": "textbook.scripts.1.BA1I",
        "documentation": {}
    },
    {
        "label": "\t\tk,d",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1I",
        "description": "textbook.scripts.1.BA1I",
        "peekOfCode": "\t\tk,d = [int(x) for x in f.readline().strip().split()]\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef immediate_neighbors(pattern):\n\tneighborhood = set()\n\tfor i in range(len(pattern)):",
        "detail": "textbook.scripts.1.BA1I",
        "documentation": {}
    },
    {
        "label": "\thamming",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1I",
        "description": "textbook.scripts.1.BA1I",
        "peekOfCode": "\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef immediate_neighbors(pattern):\n\tneighborhood = set()\n\tfor i in range(len(pattern)):\n\t\tsymbol = pattern[i]\n\t\tfor x in 'ACGT':",
        "detail": "textbook.scripts.1.BA1I",
        "documentation": {}
    },
    {
        "label": "\tneighborhood",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1I",
        "description": "textbook.scripts.1.BA1I",
        "peekOfCode": "\tneighborhood = set()\n\tfor i in range(len(pattern)):\n\t\tsymbol = pattern[i]\n\t\tfor x in 'ACGT':\n\t\t\tneighborhood.add(pattern[:i]+x+pattern[i+1:])\n\treturn neighborhood\ndef neighbors(pattern,d):\n\tif d == 0:\n\t\treturn {pattern}\n\tif len(pattern) == 1:",
        "detail": "textbook.scripts.1.BA1I",
        "documentation": {}
    },
    {
        "label": "\t\tsymbol",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1I",
        "description": "textbook.scripts.1.BA1I",
        "peekOfCode": "\t\tsymbol = pattern[i]\n\t\tfor x in 'ACGT':\n\t\t\tneighborhood.add(pattern[:i]+x+pattern[i+1:])\n\treturn neighborhood\ndef neighbors(pattern,d):\n\tif d == 0:\n\t\treturn {pattern}\n\tif len(pattern) == 1:\n\t\treturn {'A','C','G','T'}\n\tneighborhood = set()",
        "detail": "textbook.scripts.1.BA1I",
        "documentation": {}
    },
    {
        "label": "\tneighborhood",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1I",
        "description": "textbook.scripts.1.BA1I",
        "peekOfCode": "\tneighborhood = set()\n\tsuffix_neighbors = neighbors(pattern[1:],d)\n\tfor text in suffix_neighbors:\n\t\tif hamming_distance(pattern[1:],text) < d:\n\t\t\tfor x in 'ACGT':\n\t\t\t\tneighborhood.add(x+text)\n\t\telse:\n\t\t\tneighborhood.add(pattern[0]+text)\n\treturn neighborhood\ndef find_frequent_words_with_mismatches(genome,k,d):",
        "detail": "textbook.scripts.1.BA1I",
        "documentation": {}
    },
    {
        "label": "\tsuffix_neighbors",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1I",
        "description": "textbook.scripts.1.BA1I",
        "peekOfCode": "\tsuffix_neighbors = neighbors(pattern[1:],d)\n\tfor text in suffix_neighbors:\n\t\tif hamming_distance(pattern[1:],text) < d:\n\t\t\tfor x in 'ACGT':\n\t\t\t\tneighborhood.add(x+text)\n\t\telse:\n\t\t\tneighborhood.add(pattern[0]+text)\n\treturn neighborhood\ndef find_frequent_words_with_mismatches(genome,k,d):\n\tkmers = []",
        "detail": "textbook.scripts.1.BA1I",
        "documentation": {}
    },
    {
        "label": "\tkmers",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1I",
        "description": "textbook.scripts.1.BA1I",
        "peekOfCode": "\tkmers = []\n\tfor i in range(len(genome)-k+1):\n\t\tpattern = genome[i:i+k]\n\t\tkmers.extend(neighbors(pattern,d))\n\tfreqs= {}\n\tfor kmer in kmers:\n\t\tif kmer in freqs:\n\t\t\tfreqs[kmer] += 1\n\t\telse:\n\t\t\tfreqs[kmer] = 1",
        "detail": "textbook.scripts.1.BA1I",
        "documentation": {}
    },
    {
        "label": "\t\tpattern",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1I",
        "description": "textbook.scripts.1.BA1I",
        "peekOfCode": "\t\tpattern = genome[i:i+k]\n\t\tkmers.extend(neighbors(pattern,d))\n\tfreqs= {}\n\tfor kmer in kmers:\n\t\tif kmer in freqs:\n\t\t\tfreqs[kmer] += 1\n\t\telse:\n\t\t\tfreqs[kmer] = 1\n\tmax_freq = max(freqs.values())\n\treturn [kmer for kmer in freqs if freqs[kmer] == max_freq]",
        "detail": "textbook.scripts.1.BA1I",
        "documentation": {}
    },
    {
        "label": "\t\t\tfreqs[kmer]",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1I",
        "description": "textbook.scripts.1.BA1I",
        "peekOfCode": "\t\t\tfreqs[kmer] = 1\n\tmax_freq = max(freqs.values())\n\treturn [kmer for kmer in freqs if freqs[kmer] == max_freq]\nprint(' '.join(find_frequent_words_with_mismatches(genome,k,d)))",
        "detail": "textbook.scripts.1.BA1I",
        "documentation": {}
    },
    {
        "label": "\tmax_freq",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1I",
        "description": "textbook.scripts.1.BA1I",
        "peekOfCode": "\tmax_freq = max(freqs.values())\n\treturn [kmer for kmer in freqs if freqs[kmer] == max_freq]\nprint(' '.join(find_frequent_words_with_mismatches(genome,k,d)))",
        "detail": "textbook.scripts.1.BA1I",
        "documentation": {}
    },
    {
        "label": "revc",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "def revc(dna):\n\treturn ''.join([{'A':'T','T':'A','C':'G','G':'C'}[i] for i in dna])[::-1]\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef immediate_neighbors(pattern):\n\tneighborhood = set()",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "hamming_distance",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "def hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef immediate_neighbors(pattern):\n\tneighborhood = set()\n\tfor i in range(len(pattern)):\n\t\tsymbol = pattern[i]",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "immediate_neighbors",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "def immediate_neighbors(pattern):\n\tneighborhood = set()\n\tfor i in range(len(pattern)):\n\t\tsymbol = pattern[i]\n\t\tfor x in 'ACGT':\n\t\t\tneighborhood.add(pattern[:i]+x+pattern[i+1:])\n\treturn neighborhood\ndef neighbors(pattern,d):\n\tif d == 0:\n\t\treturn {pattern}",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "neighbors",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "def neighbors(pattern,d):\n\tif d == 0:\n\t\treturn {pattern}\n\tif len(pattern) == 1:\n\t\treturn {'A','C','G','T'}\n\tneighborhood = set()\n\tsuffix_neighbors = neighbors(pattern[1:],d)\n\tfor text in suffix_neighbors:\n\t\tif hamming_distance(pattern[1:],text) < d:\n\t\t\tfor x in 'ACGT':",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "find_frequent_words_with_mismatches_and_revcomp",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "def find_frequent_words_with_mismatches_and_revcomp(genome,k,d):\n\tkmers = []\n\tfor i in range(len(genome)-k+1):\n\t\tpattern = genome[i:i+k]\n\t\tkmers.extend(neighbors(pattern,d))\n\trevc_genome = revc(genome)\n\tfor i in range(len(revc_genome)-k+1):\n\t\tpattern = revc_genome[i:i+k]\n\t\tkmers.extend(neighbors(pattern,d))\n\tfreqs= {}",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.append('..')\n\t\tdatapath.append('data')\n\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1j.txt')) as f:\n\t\t# read data",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1j.txt')) as f:\n\t\t# read data\n\t\tgenome = f.readline().strip()\n\t\tk,d = [int(x) for x in f.readline().strip().split()]\ndef revc(dna):\n\treturn ''.join([{'A':'T','T':'A','C':'G','G':'C'}[i] for i in dna])[::-1]\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "\t\tgenome",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "\t\tgenome = f.readline().strip()\n\t\tk,d = [int(x) for x in f.readline().strip().split()]\ndef revc(dna):\n\treturn ''.join([{'A':'T','T':'A','C':'G','G':'C'}[i] for i in dna])[::-1]\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "\t\tk,d",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "\t\tk,d = [int(x) for x in f.readline().strip().split()]\ndef revc(dna):\n\treturn ''.join([{'A':'T','T':'A','C':'G','G':'C'}[i] for i in dna])[::-1]\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef immediate_neighbors(pattern):",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "\thamming",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef immediate_neighbors(pattern):\n\tneighborhood = set()\n\tfor i in range(len(pattern)):\n\t\tsymbol = pattern[i]\n\t\tfor x in 'ACGT':",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "\tneighborhood",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "\tneighborhood = set()\n\tfor i in range(len(pattern)):\n\t\tsymbol = pattern[i]\n\t\tfor x in 'ACGT':\n\t\t\tneighborhood.add(pattern[:i]+x+pattern[i+1:])\n\treturn neighborhood\ndef neighbors(pattern,d):\n\tif d == 0:\n\t\treturn {pattern}\n\tif len(pattern) == 1:",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "\t\tsymbol",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "\t\tsymbol = pattern[i]\n\t\tfor x in 'ACGT':\n\t\t\tneighborhood.add(pattern[:i]+x+pattern[i+1:])\n\treturn neighborhood\ndef neighbors(pattern,d):\n\tif d == 0:\n\t\treturn {pattern}\n\tif len(pattern) == 1:\n\t\treturn {'A','C','G','T'}\n\tneighborhood = set()",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "\tneighborhood",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "\tneighborhood = set()\n\tsuffix_neighbors = neighbors(pattern[1:],d)\n\tfor text in suffix_neighbors:\n\t\tif hamming_distance(pattern[1:],text) < d:\n\t\t\tfor x in 'ACGT':\n\t\t\t\tneighborhood.add(x+text)\n\t\telse:\n\t\t\tneighborhood.add(pattern[0]+text)\n\treturn neighborhood\ndef find_frequent_words_with_mismatches_and_revcomp(genome,k,d):",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "\tsuffix_neighbors",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "\tsuffix_neighbors = neighbors(pattern[1:],d)\n\tfor text in suffix_neighbors:\n\t\tif hamming_distance(pattern[1:],text) < d:\n\t\t\tfor x in 'ACGT':\n\t\t\t\tneighborhood.add(x+text)\n\t\telse:\n\t\t\tneighborhood.add(pattern[0]+text)\n\treturn neighborhood\ndef find_frequent_words_with_mismatches_and_revcomp(genome,k,d):\n\tkmers = []",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "\tkmers",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "\tkmers = []\n\tfor i in range(len(genome)-k+1):\n\t\tpattern = genome[i:i+k]\n\t\tkmers.extend(neighbors(pattern,d))\n\trevc_genome = revc(genome)\n\tfor i in range(len(revc_genome)-k+1):\n\t\tpattern = revc_genome[i:i+k]\n\t\tkmers.extend(neighbors(pattern,d))\n\tfreqs= {}\n\tfor kmer in kmers:",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "\t\tpattern",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "\t\tpattern = genome[i:i+k]\n\t\tkmers.extend(neighbors(pattern,d))\n\trevc_genome = revc(genome)\n\tfor i in range(len(revc_genome)-k+1):\n\t\tpattern = revc_genome[i:i+k]\n\t\tkmers.extend(neighbors(pattern,d))\n\tfreqs= {}\n\tfor kmer in kmers:\n\t\tif kmer in freqs:\n\t\t\tfreqs[kmer] += 1",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "\trevc_genome",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "\trevc_genome = revc(genome)\n\tfor i in range(len(revc_genome)-k+1):\n\t\tpattern = revc_genome[i:i+k]\n\t\tkmers.extend(neighbors(pattern,d))\n\tfreqs= {}\n\tfor kmer in kmers:\n\t\tif kmer in freqs:\n\t\t\tfreqs[kmer] += 1\n\t\telse:\n\t\t\tfreqs[kmer] = 1",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "\t\tpattern",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "\t\tpattern = revc_genome[i:i+k]\n\t\tkmers.extend(neighbors(pattern,d))\n\tfreqs= {}\n\tfor kmer in kmers:\n\t\tif kmer in freqs:\n\t\t\tfreqs[kmer] += 1\n\t\telse:\n\t\t\tfreqs[kmer] = 1\n\tmax_freq = max(freqs.values())\n\treturn [kmer for kmer in freqs if freqs[kmer] == max_freq]",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "\t\t\tfreqs[kmer]",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "\t\t\tfreqs[kmer] = 1\n\tmax_freq = max(freqs.values())\n\treturn [kmer for kmer in freqs if freqs[kmer] == max_freq]\nprint(' '.join(find_frequent_words_with_mismatches_and_revcomp(genome,k,d)))",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "\tmax_freq",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1J",
        "description": "textbook.scripts.1.BA1J",
        "peekOfCode": "\tmax_freq = max(freqs.values())\n\treturn [kmer for kmer in freqs if freqs[kmer] == max_freq]\nprint(' '.join(find_frequent_words_with_mismatches_and_revcomp(genome,k,d)))",
        "detail": "textbook.scripts.1.BA1J",
        "documentation": {}
    },
    {
        "label": "number_to_symbol",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1K",
        "description": "textbook.scripts.1.BA1K",
        "peekOfCode": "def number_to_symbol(number):\n\treturn {0:'A',1:'C',2:'G',3:'T'}[number]\ndef number_to_pattern(index,k):\n\tif k == 1:\n\t\treturn number_to_symbol(index)\n\tprefix_index = index // 4\n\tr = index % 4\n\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol",
        "detail": "textbook.scripts.1.BA1K",
        "documentation": {}
    },
    {
        "label": "number_to_pattern",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1K",
        "description": "textbook.scripts.1.BA1K",
        "peekOfCode": "def number_to_pattern(index,k):\n\tif k == 1:\n\t\treturn number_to_symbol(index)\n\tprefix_index = index // 4\n\tr = index % 4\n\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\ndef frequency_array(genome,k):\n\tkmers = []",
        "detail": "textbook.scripts.1.BA1K",
        "documentation": {}
    },
    {
        "label": "frequency_array",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1K",
        "description": "textbook.scripts.1.BA1K",
        "peekOfCode": "def frequency_array(genome,k):\n\tkmers = []\n\tfor i in range(len(genome)-k+1):\n\t\tpattern = genome[i:i+k]\n\t\tkmers.append(pattern)\n\tall_kmers = [number_to_pattern(x,k) for x in range(4**k)]\n\tfreqs= {kmer:0 for kmer in all_kmers}\n\tfor kmer in kmers:\n\t\tfreqs[kmer] += 1\n\t# sort freqs by key lexicographically",
        "detail": "textbook.scripts.1.BA1K",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1K",
        "description": "textbook.scripts.1.BA1K",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.append('..')\n\t\tdatapath.append('data')\n\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1k.txt')) as f:\n\t\t# read data",
        "detail": "textbook.scripts.1.BA1K",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1K",
        "description": "textbook.scripts.1.BA1K",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1k.txt')) as f:\n\t\t# read data\n\t\tgenome = f.readline().strip()\n\t\tk = int(f.readline().strip())\ndef number_to_symbol(number):\n\treturn {0:'A',1:'C',2:'G',3:'T'}[number]\ndef number_to_pattern(index,k):\n\tif k == 1:\n\t\treturn number_to_symbol(index)",
        "detail": "textbook.scripts.1.BA1K",
        "documentation": {}
    },
    {
        "label": "\t\tgenome",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1K",
        "description": "textbook.scripts.1.BA1K",
        "peekOfCode": "\t\tgenome = f.readline().strip()\n\t\tk = int(f.readline().strip())\ndef number_to_symbol(number):\n\treturn {0:'A',1:'C',2:'G',3:'T'}[number]\ndef number_to_pattern(index,k):\n\tif k == 1:\n\t\treturn number_to_symbol(index)\n\tprefix_index = index // 4\n\tr = index % 4\n\tsymbol = number_to_symbol(r)",
        "detail": "textbook.scripts.1.BA1K",
        "documentation": {}
    },
    {
        "label": "\t\tk",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1K",
        "description": "textbook.scripts.1.BA1K",
        "peekOfCode": "\t\tk = int(f.readline().strip())\ndef number_to_symbol(number):\n\treturn {0:'A',1:'C',2:'G',3:'T'}[number]\ndef number_to_pattern(index,k):\n\tif k == 1:\n\t\treturn number_to_symbol(index)\n\tprefix_index = index // 4\n\tr = index % 4\n\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)",
        "detail": "textbook.scripts.1.BA1K",
        "documentation": {}
    },
    {
        "label": "\tprefix_index",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1K",
        "description": "textbook.scripts.1.BA1K",
        "peekOfCode": "\tprefix_index = index // 4\n\tr = index % 4\n\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\ndef frequency_array(genome,k):\n\tkmers = []\n\tfor i in range(len(genome)-k+1):\n\t\tpattern = genome[i:i+k]\n\t\tkmers.append(pattern)",
        "detail": "textbook.scripts.1.BA1K",
        "documentation": {}
    },
    {
        "label": "\tr",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1K",
        "description": "textbook.scripts.1.BA1K",
        "peekOfCode": "\tr = index % 4\n\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\ndef frequency_array(genome,k):\n\tkmers = []\n\tfor i in range(len(genome)-k+1):\n\t\tpattern = genome[i:i+k]\n\t\tkmers.append(pattern)\n\tall_kmers = [number_to_pattern(x,k) for x in range(4**k)]",
        "detail": "textbook.scripts.1.BA1K",
        "documentation": {}
    },
    {
        "label": "\tsymbol",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1K",
        "description": "textbook.scripts.1.BA1K",
        "peekOfCode": "\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\ndef frequency_array(genome,k):\n\tkmers = []\n\tfor i in range(len(genome)-k+1):\n\t\tpattern = genome[i:i+k]\n\t\tkmers.append(pattern)\n\tall_kmers = [number_to_pattern(x,k) for x in range(4**k)]\n\tfreqs= {kmer:0 for kmer in all_kmers}",
        "detail": "textbook.scripts.1.BA1K",
        "documentation": {}
    },
    {
        "label": "\tprefix_pattern",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1K",
        "description": "textbook.scripts.1.BA1K",
        "peekOfCode": "\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\ndef frequency_array(genome,k):\n\tkmers = []\n\tfor i in range(len(genome)-k+1):\n\t\tpattern = genome[i:i+k]\n\t\tkmers.append(pattern)\n\tall_kmers = [number_to_pattern(x,k) for x in range(4**k)]\n\tfreqs= {kmer:0 for kmer in all_kmers}\n\tfor kmer in kmers:",
        "detail": "textbook.scripts.1.BA1K",
        "documentation": {}
    },
    {
        "label": "\tkmers",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1K",
        "description": "textbook.scripts.1.BA1K",
        "peekOfCode": "\tkmers = []\n\tfor i in range(len(genome)-k+1):\n\t\tpattern = genome[i:i+k]\n\t\tkmers.append(pattern)\n\tall_kmers = [number_to_pattern(x,k) for x in range(4**k)]\n\tfreqs= {kmer:0 for kmer in all_kmers}\n\tfor kmer in kmers:\n\t\tfreqs[kmer] += 1\n\t# sort freqs by key lexicographically\n\tfreqs = sorted(freqs.items(),key=lambda x: x[0])",
        "detail": "textbook.scripts.1.BA1K",
        "documentation": {}
    },
    {
        "label": "\t\tpattern",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1K",
        "description": "textbook.scripts.1.BA1K",
        "peekOfCode": "\t\tpattern = genome[i:i+k]\n\t\tkmers.append(pattern)\n\tall_kmers = [number_to_pattern(x,k) for x in range(4**k)]\n\tfreqs= {kmer:0 for kmer in all_kmers}\n\tfor kmer in kmers:\n\t\tfreqs[kmer] += 1\n\t# sort freqs by key lexicographically\n\tfreqs = sorted(freqs.items(),key=lambda x: x[0])\n\treturn freqs\nprint(' '.join([str(x[1]) for x in frequency_array(genome,k)]))",
        "detail": "textbook.scripts.1.BA1K",
        "documentation": {}
    },
    {
        "label": "\tall_kmers",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1K",
        "description": "textbook.scripts.1.BA1K",
        "peekOfCode": "\tall_kmers = [number_to_pattern(x,k) for x in range(4**k)]\n\tfreqs= {kmer:0 for kmer in all_kmers}\n\tfor kmer in kmers:\n\t\tfreqs[kmer] += 1\n\t# sort freqs by key lexicographically\n\tfreqs = sorted(freqs.items(),key=lambda x: x[0])\n\treturn freqs\nprint(' '.join([str(x[1]) for x in frequency_array(genome,k)]))",
        "detail": "textbook.scripts.1.BA1K",
        "documentation": {}
    },
    {
        "label": "\tfreqs",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1K",
        "description": "textbook.scripts.1.BA1K",
        "peekOfCode": "\tfreqs = sorted(freqs.items(),key=lambda x: x[0])\n\treturn freqs\nprint(' '.join([str(x[1]) for x in frequency_array(genome,k)]))",
        "detail": "textbook.scripts.1.BA1K",
        "documentation": {}
    },
    {
        "label": "symbol_to_number",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1L",
        "description": "textbook.scripts.1.BA1L",
        "peekOfCode": "def symbol_to_number(symbol):\n\treturn {'A':0,'C':1,'G':2,'T':3}[symbol]\ndef pattern_to_number(pattern):\n\tif len(pattern) == 0:\n\t\treturn 0\n\tsymbol = pattern[-1]\n\tprefix = pattern[:-1]\n\treturn 4*pattern_to_number(prefix) + symbol_to_number(symbol)\nprint(pattern_to_number(pattern))",
        "detail": "textbook.scripts.1.BA1L",
        "documentation": {}
    },
    {
        "label": "pattern_to_number",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1L",
        "description": "textbook.scripts.1.BA1L",
        "peekOfCode": "def pattern_to_number(pattern):\n\tif len(pattern) == 0:\n\t\treturn 0\n\tsymbol = pattern[-1]\n\tprefix = pattern[:-1]\n\treturn 4*pattern_to_number(prefix) + symbol_to_number(symbol)\nprint(pattern_to_number(pattern))",
        "detail": "textbook.scripts.1.BA1L",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1L",
        "description": "textbook.scripts.1.BA1L",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.append('..')\n\t\tdatapath.append('data')\n\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1l.txt')) as f:\n\t\t# read data",
        "detail": "textbook.scripts.1.BA1L",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1L",
        "description": "textbook.scripts.1.BA1L",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1l.txt')) as f:\n\t\t# read data\n\t\tpattern = f.readline().strip()\ndef symbol_to_number(symbol):\n\treturn {'A':0,'C':1,'G':2,'T':3}[symbol]\ndef pattern_to_number(pattern):\n\tif len(pattern) == 0:\n\t\treturn 0\n\tsymbol = pattern[-1]",
        "detail": "textbook.scripts.1.BA1L",
        "documentation": {}
    },
    {
        "label": "\t\tpattern",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1L",
        "description": "textbook.scripts.1.BA1L",
        "peekOfCode": "\t\tpattern = f.readline().strip()\ndef symbol_to_number(symbol):\n\treturn {'A':0,'C':1,'G':2,'T':3}[symbol]\ndef pattern_to_number(pattern):\n\tif len(pattern) == 0:\n\t\treturn 0\n\tsymbol = pattern[-1]\n\tprefix = pattern[:-1]\n\treturn 4*pattern_to_number(prefix) + symbol_to_number(symbol)\nprint(pattern_to_number(pattern))",
        "detail": "textbook.scripts.1.BA1L",
        "documentation": {}
    },
    {
        "label": "\tsymbol",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1L",
        "description": "textbook.scripts.1.BA1L",
        "peekOfCode": "\tsymbol = pattern[-1]\n\tprefix = pattern[:-1]\n\treturn 4*pattern_to_number(prefix) + symbol_to_number(symbol)\nprint(pattern_to_number(pattern))",
        "detail": "textbook.scripts.1.BA1L",
        "documentation": {}
    },
    {
        "label": "\tprefix",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1L",
        "description": "textbook.scripts.1.BA1L",
        "peekOfCode": "\tprefix = pattern[:-1]\n\treturn 4*pattern_to_number(prefix) + symbol_to_number(symbol)\nprint(pattern_to_number(pattern))",
        "detail": "textbook.scripts.1.BA1L",
        "documentation": {}
    },
    {
        "label": "number_to_symbol",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1M",
        "description": "textbook.scripts.1.BA1M",
        "peekOfCode": "def number_to_symbol(number):\n\treturn {0:'A',1:'C',2:'G',3:'T'}[number]\ndef number_to_pattern(index,k):\n\tif k == 1:\n\t\treturn number_to_symbol(index)\n\tprefix_index = index // 4\n\tr = index % 4\n\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol",
        "detail": "textbook.scripts.1.BA1M",
        "documentation": {}
    },
    {
        "label": "number_to_pattern",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1M",
        "description": "textbook.scripts.1.BA1M",
        "peekOfCode": "def number_to_pattern(index,k):\n\tif k == 1:\n\t\treturn number_to_symbol(index)\n\tprefix_index = index // 4\n\tr = index % 4\n\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\nprint(number_to_pattern(number,k))",
        "detail": "textbook.scripts.1.BA1M",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1M",
        "description": "textbook.scripts.1.BA1M",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.append('..')\n\t\tdatapath.append('data')\n\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1m.txt')) as f:\n\t\t# read data",
        "detail": "textbook.scripts.1.BA1M",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1M",
        "description": "textbook.scripts.1.BA1M",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1m.txt')) as f:\n\t\t# read data\n\t\tnumber = int(f.readline().strip())\n\t\tk = int(f.readline().strip())\ndef number_to_symbol(number):\n\treturn {0:'A',1:'C',2:'G',3:'T'}[number]\ndef number_to_pattern(index,k):\n\tif k == 1:\n\t\treturn number_to_symbol(index)",
        "detail": "textbook.scripts.1.BA1M",
        "documentation": {}
    },
    {
        "label": "\t\tnumber",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1M",
        "description": "textbook.scripts.1.BA1M",
        "peekOfCode": "\t\tnumber = int(f.readline().strip())\n\t\tk = int(f.readline().strip())\ndef number_to_symbol(number):\n\treturn {0:'A',1:'C',2:'G',3:'T'}[number]\ndef number_to_pattern(index,k):\n\tif k == 1:\n\t\treturn number_to_symbol(index)\n\tprefix_index = index // 4\n\tr = index % 4\n\tsymbol = number_to_symbol(r)",
        "detail": "textbook.scripts.1.BA1M",
        "documentation": {}
    },
    {
        "label": "\t\tk",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1M",
        "description": "textbook.scripts.1.BA1M",
        "peekOfCode": "\t\tk = int(f.readline().strip())\ndef number_to_symbol(number):\n\treturn {0:'A',1:'C',2:'G',3:'T'}[number]\ndef number_to_pattern(index,k):\n\tif k == 1:\n\t\treturn number_to_symbol(index)\n\tprefix_index = index // 4\n\tr = index % 4\n\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)",
        "detail": "textbook.scripts.1.BA1M",
        "documentation": {}
    },
    {
        "label": "\tprefix_index",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1M",
        "description": "textbook.scripts.1.BA1M",
        "peekOfCode": "\tprefix_index = index // 4\n\tr = index % 4\n\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\nprint(number_to_pattern(number,k))",
        "detail": "textbook.scripts.1.BA1M",
        "documentation": {}
    },
    {
        "label": "\tr",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1M",
        "description": "textbook.scripts.1.BA1M",
        "peekOfCode": "\tr = index % 4\n\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\nprint(number_to_pattern(number,k))",
        "detail": "textbook.scripts.1.BA1M",
        "documentation": {}
    },
    {
        "label": "\tsymbol",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1M",
        "description": "textbook.scripts.1.BA1M",
        "peekOfCode": "\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\nprint(number_to_pattern(number,k))",
        "detail": "textbook.scripts.1.BA1M",
        "documentation": {}
    },
    {
        "label": "\tprefix_pattern",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1M",
        "description": "textbook.scripts.1.BA1M",
        "peekOfCode": "\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\nprint(number_to_pattern(number,k))",
        "detail": "textbook.scripts.1.BA1M",
        "documentation": {}
    },
    {
        "label": "hamming_distance",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1N",
        "description": "textbook.scripts.1.BA1N",
        "peekOfCode": "def hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef immediate_neighbors(pattern):\n\tneighborhood = set()\n\tfor i in range(len(pattern)):\n\t\tsymbol = pattern[i]",
        "detail": "textbook.scripts.1.BA1N",
        "documentation": {}
    },
    {
        "label": "immediate_neighbors",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1N",
        "description": "textbook.scripts.1.BA1N",
        "peekOfCode": "def immediate_neighbors(pattern):\n\tneighborhood = set()\n\tfor i in range(len(pattern)):\n\t\tsymbol = pattern[i]\n\t\tfor x in 'ACGT':\n\t\t\tneighborhood.add(pattern[:i]+x+pattern[i+1:])\n\treturn neighborhood\ndef neighbors(pattern,d):\n\tif d == 0:\n\t\treturn {pattern}",
        "detail": "textbook.scripts.1.BA1N",
        "documentation": {}
    },
    {
        "label": "neighbors",
        "kind": 2,
        "importPath": "textbook.scripts.1.BA1N",
        "description": "textbook.scripts.1.BA1N",
        "peekOfCode": "def neighbors(pattern,d):\n\tif d == 0:\n\t\treturn {pattern}\n\tif len(pattern) == 1:\n\t\treturn {'A','C','G','T'}\n\tneighborhood = set()\n\tsuffix_neighbors = neighbors(pattern[1:],d) \n\tfor text in suffix_neighbors:\n\t\tif hamming_distance(pattern[1:],text) < d:\n\t\t\tfor x in 'ACGT':",
        "detail": "textbook.scripts.1.BA1N",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1N",
        "description": "textbook.scripts.1.BA1N",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.append('..')\n\t\tdatapath.append('data')\n\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1n.txt')) as f:\n\t\t# read data",
        "detail": "textbook.scripts.1.BA1N",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1N",
        "description": "textbook.scripts.1.BA1N",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\twith open(os.path.join(datapath,'rosalind_ba1n.txt')) as f:\n\t\t# read data\n\t\tpattern = f.readline().strip()\n\t\td = int(f.readline().strip())\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1",
        "detail": "textbook.scripts.1.BA1N",
        "documentation": {}
    },
    {
        "label": "\t\tpattern",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1N",
        "description": "textbook.scripts.1.BA1N",
        "peekOfCode": "\t\tpattern = f.readline().strip()\n\t\td = int(f.readline().strip())\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef immediate_neighbors(pattern):\n\tneighborhood = set()",
        "detail": "textbook.scripts.1.BA1N",
        "documentation": {}
    },
    {
        "label": "\t\td",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1N",
        "description": "textbook.scripts.1.BA1N",
        "peekOfCode": "\t\td = int(f.readline().strip())\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef immediate_neighbors(pattern):\n\tneighborhood = set()\n\tfor i in range(len(pattern)):",
        "detail": "textbook.scripts.1.BA1N",
        "documentation": {}
    },
    {
        "label": "\thamming",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1N",
        "description": "textbook.scripts.1.BA1N",
        "peekOfCode": "\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef immediate_neighbors(pattern):\n\tneighborhood = set()\n\tfor i in range(len(pattern)):\n\t\tsymbol = pattern[i]\n\t\tfor x in 'ACGT':",
        "detail": "textbook.scripts.1.BA1N",
        "documentation": {}
    },
    {
        "label": "\tneighborhood",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1N",
        "description": "textbook.scripts.1.BA1N",
        "peekOfCode": "\tneighborhood = set()\n\tfor i in range(len(pattern)):\n\t\tsymbol = pattern[i]\n\t\tfor x in 'ACGT':\n\t\t\tneighborhood.add(pattern[:i]+x+pattern[i+1:])\n\treturn neighborhood\ndef neighbors(pattern,d):\n\tif d == 0:\n\t\treturn {pattern}\n\tif len(pattern) == 1:",
        "detail": "textbook.scripts.1.BA1N",
        "documentation": {}
    },
    {
        "label": "\t\tsymbol",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1N",
        "description": "textbook.scripts.1.BA1N",
        "peekOfCode": "\t\tsymbol = pattern[i]\n\t\tfor x in 'ACGT':\n\t\t\tneighborhood.add(pattern[:i]+x+pattern[i+1:])\n\treturn neighborhood\ndef neighbors(pattern,d):\n\tif d == 0:\n\t\treturn {pattern}\n\tif len(pattern) == 1:\n\t\treturn {'A','C','G','T'}\n\tneighborhood = set()",
        "detail": "textbook.scripts.1.BA1N",
        "documentation": {}
    },
    {
        "label": "\tneighborhood",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1N",
        "description": "textbook.scripts.1.BA1N",
        "peekOfCode": "\tneighborhood = set()\n\tsuffix_neighbors = neighbors(pattern[1:],d) \n\tfor text in suffix_neighbors:\n\t\tif hamming_distance(pattern[1:],text) < d:\n\t\t\tfor x in 'ACGT':\n\t\t\t\tneighborhood.add(x+text)\n\t\telse:\n\t\t\tneighborhood.add(pattern[0]+text)\n\treturn neighborhood\nprint(*neighbors(pattern,d),sep='\\n')",
        "detail": "textbook.scripts.1.BA1N",
        "documentation": {}
    },
    {
        "label": "\tsuffix_neighbors",
        "kind": 5,
        "importPath": "textbook.scripts.1.BA1N",
        "description": "textbook.scripts.1.BA1N",
        "peekOfCode": "\tsuffix_neighbors = neighbors(pattern[1:],d) \n\tfor text in suffix_neighbors:\n\t\tif hamming_distance(pattern[1:],text) < d:\n\t\t\tfor x in 'ACGT':\n\t\t\t\tneighborhood.add(x+text)\n\t\telse:\n\t\t\tneighborhood.add(pattern[0]+text)\n\treturn neighborhood\nprint(*neighbors(pattern,d),sep='\\n')",
        "detail": "textbook.scripts.1.BA1N",
        "documentation": {}
    },
    {
        "label": "hamming_distance",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2A",
        "description": "textbook.scripts.2.BA2A",
        "peekOfCode": "def hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef neighbors(pattern,d):\n\tif d == 0:\n\t\treturn {pattern}\n\tif len(pattern) == 1:",
        "detail": "textbook.scripts.2.BA2A",
        "documentation": {}
    },
    {
        "label": "neighbors",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2A",
        "description": "textbook.scripts.2.BA2A",
        "peekOfCode": "def neighbors(pattern,d):\n\tif d == 0:\n\t\treturn {pattern}\n\tif len(pattern) == 1:\n\t\treturn {'A','C','G','T'}\n\tneighborhood = set()\n\tsuffix_neighbors = neighbors(pattern[1:],d)\n\tfor text in suffix_neighbors:\n\t\tif hamming_distance(pattern[1:],text) < d:\n\t\t\tfor x in 'ACGT':",
        "detail": "textbook.scripts.2.BA2A",
        "documentation": {}
    },
    {
        "label": "motif_enumeration",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2A",
        "description": "textbook.scripts.2.BA2A",
        "peekOfCode": "def motif_enumeration(dna, k, d):\n\tpatterns = set()\n\tfor dna_str in dna:\n\t\tfor i in range(len(dna_str)-k):\n\t\t\tpattern = dna_str[i:i+k]\n\t\t\tneighborhood = neighbors(pattern,d)\n\t\t\tfor p1 in neighborhood:\n\t\t\t\tp1_neighbors = neighbors(p1,d)\n\t\t\t\tfor dna_str2 in dna:\n\t\t\t\t\t# if none of the neighbors are in dna_str2, break",
        "detail": "textbook.scripts.2.BA2A",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2A",
        "description": "textbook.scripts.2.BA2A",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.extend(['..','..','data'])\n\tdatapath = os.path.join(*datapath)\n\ttry:\n\t\twith open(os.path.join(datapath,'rosalind_ba2a.txt')) as f:\n\t\t\tk,d = [int(x) for x in f.readline().strip().split()]",
        "detail": "textbook.scripts.2.BA2A",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2A",
        "description": "textbook.scripts.2.BA2A",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\ttry:\n\t\twith open(os.path.join(datapath,'rosalind_ba2a.txt')) as f:\n\t\t\tk,d = [int(x) for x in f.readline().strip().split()]\n\t\t\tdna = [x.strip() for x in f.readlines()]\n\texcept:\n\t\tpass\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):",
        "detail": "textbook.scripts.2.BA2A",
        "documentation": {}
    },
    {
        "label": "\t\t\tk,d",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2A",
        "description": "textbook.scripts.2.BA2A",
        "peekOfCode": "\t\t\tk,d = [int(x) for x in f.readline().strip().split()]\n\t\t\tdna = [x.strip() for x in f.readlines()]\n\texcept:\n\t\tpass\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming",
        "detail": "textbook.scripts.2.BA2A",
        "documentation": {}
    },
    {
        "label": "\t\t\tdna",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2A",
        "description": "textbook.scripts.2.BA2A",
        "peekOfCode": "\t\t\tdna = [x.strip() for x in f.readlines()]\n\texcept:\n\t\tpass\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef neighbors(pattern,d):",
        "detail": "textbook.scripts.2.BA2A",
        "documentation": {}
    },
    {
        "label": "\thamming",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2A",
        "description": "textbook.scripts.2.BA2A",
        "peekOfCode": "\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef neighbors(pattern,d):\n\tif d == 0:\n\t\treturn {pattern}\n\tif len(pattern) == 1:\n\t\treturn {'A','C','G','T'}",
        "detail": "textbook.scripts.2.BA2A",
        "documentation": {}
    },
    {
        "label": "\tneighborhood",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2A",
        "description": "textbook.scripts.2.BA2A",
        "peekOfCode": "\tneighborhood = set()\n\tsuffix_neighbors = neighbors(pattern[1:],d)\n\tfor text in suffix_neighbors:\n\t\tif hamming_distance(pattern[1:],text) < d:\n\t\t\tfor x in 'ACGT':\n\t\t\t\tneighborhood.add(x+text)\n\t\telse:\n\t\t\tneighborhood.add(pattern[0]+text)\n\treturn neighborhood\ndef motif_enumeration(dna, k, d):",
        "detail": "textbook.scripts.2.BA2A",
        "documentation": {}
    },
    {
        "label": "\tsuffix_neighbors",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2A",
        "description": "textbook.scripts.2.BA2A",
        "peekOfCode": "\tsuffix_neighbors = neighbors(pattern[1:],d)\n\tfor text in suffix_neighbors:\n\t\tif hamming_distance(pattern[1:],text) < d:\n\t\t\tfor x in 'ACGT':\n\t\t\t\tneighborhood.add(x+text)\n\t\telse:\n\t\t\tneighborhood.add(pattern[0]+text)\n\treturn neighborhood\ndef motif_enumeration(dna, k, d):\n\tpatterns = set()",
        "detail": "textbook.scripts.2.BA2A",
        "documentation": {}
    },
    {
        "label": "\tpatterns",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2A",
        "description": "textbook.scripts.2.BA2A",
        "peekOfCode": "\tpatterns = set()\n\tfor dna_str in dna:\n\t\tfor i in range(len(dna_str)-k):\n\t\t\tpattern = dna_str[i:i+k]\n\t\t\tneighborhood = neighbors(pattern,d)\n\t\t\tfor p1 in neighborhood:\n\t\t\t\tp1_neighbors = neighbors(p1,d)\n\t\t\t\tfor dna_str2 in dna:\n\t\t\t\t\t# if none of the neighbors are in dna_str2, break\n\t\t\t\t\tif not any([p2 in dna_str2 for p2 in p1_neighbors]):",
        "detail": "textbook.scripts.2.BA2A",
        "documentation": {}
    },
    {
        "label": "\t\t\tpattern",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2A",
        "description": "textbook.scripts.2.BA2A",
        "peekOfCode": "\t\t\tpattern = dna_str[i:i+k]\n\t\t\tneighborhood = neighbors(pattern,d)\n\t\t\tfor p1 in neighborhood:\n\t\t\t\tp1_neighbors = neighbors(p1,d)\n\t\t\t\tfor dna_str2 in dna:\n\t\t\t\t\t# if none of the neighbors are in dna_str2, break\n\t\t\t\t\tif not any([p2 in dna_str2 for p2 in p1_neighbors]):\n\t\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tpatterns.add(p1)",
        "detail": "textbook.scripts.2.BA2A",
        "documentation": {}
    },
    {
        "label": "\t\t\tneighborhood",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2A",
        "description": "textbook.scripts.2.BA2A",
        "peekOfCode": "\t\t\tneighborhood = neighbors(pattern,d)\n\t\t\tfor p1 in neighborhood:\n\t\t\t\tp1_neighbors = neighbors(p1,d)\n\t\t\t\tfor dna_str2 in dna:\n\t\t\t\t\t# if none of the neighbors are in dna_str2, break\n\t\t\t\t\tif not any([p2 in dna_str2 for p2 in p1_neighbors]):\n\t\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tpatterns.add(p1)\n\treturn patterns",
        "detail": "textbook.scripts.2.BA2A",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tp1_neighbors",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2A",
        "description": "textbook.scripts.2.BA2A",
        "peekOfCode": "\t\t\t\tp1_neighbors = neighbors(p1,d)\n\t\t\t\tfor dna_str2 in dna:\n\t\t\t\t\t# if none of the neighbors are in dna_str2, break\n\t\t\t\t\tif not any([p2 in dna_str2 for p2 in p1_neighbors]):\n\t\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tpatterns.add(p1)\n\treturn patterns\n# print(motif_enumeration(['ATTTGGC','TGCCTTA','CGGTATC','GAAAATT'],3,1))\nprint(' '.join(list(motif_enumeration(dna,k,d))))",
        "detail": "textbook.scripts.2.BA2A",
        "documentation": {}
    },
    {
        "label": "symbol_to_number",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "def symbol_to_number(symbol):\n\treturn {'A':0,'C':1,'G':2,'T':3}[symbol]\ndef pattern_to_number(pattern):\n\tif len(pattern) == 0:\n\t\treturn 0\n\tsymbol = pattern[-1]\n\tprefix = pattern[:-1]\n\treturn 4*pattern_to_number(prefix) + symbol_to_number(symbol)\ndef number_to_symbol(number):\n\treturn {0:'A',1:'C',2:'G',3:'T'}[number]",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "pattern_to_number",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "def pattern_to_number(pattern):\n\tif len(pattern) == 0:\n\t\treturn 0\n\tsymbol = pattern[-1]\n\tprefix = pattern[:-1]\n\treturn 4*pattern_to_number(prefix) + symbol_to_number(symbol)\ndef number_to_symbol(number):\n\treturn {0:'A',1:'C',2:'G',3:'T'}[number]\ndef number_to_pattern(index,k):\n\tif k == 1:",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "number_to_symbol",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "def number_to_symbol(number):\n\treturn {0:'A',1:'C',2:'G',3:'T'}[number]\ndef number_to_pattern(index,k):\n\tif k == 1:\n\t\treturn number_to_symbol(index)\n\tprefix_index = index // 4\n\tr = index % 4\n\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "number_to_pattern",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "def number_to_pattern(index,k):\n\tif k == 1:\n\t\treturn number_to_symbol(index)\n\tprefix_index = index // 4\n\tr = index % 4\n\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\ndef hamming_distance(p,q):\n\thamming = 0",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "hamming_distance",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "def hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\n# d\ndef dist(pattern,dna):\n\tk = len(pattern)\n\tdistance = 0",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "dist",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "def dist(pattern,dna):\n\tk = len(pattern)\n\tdistance = 0\n\tfor text in dna:\n\t\thamming_dist = 100000\n\t\tfor i in range(len(text)-k+1):\n\t\t\tpattern2 = text[i:i+k]\n\t\t\thamming_dist = min(hamming_dist,hamming_distance(pattern,pattern2))\n\t\tdistance += hamming_dist\n\treturn distance",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "median_string",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "def median_string(dna,k):\n\tdistance = 100000\n\tmedian = ''\n\tfor i in range(4**k):\n\t\tpattern = number_to_pattern(i,k)\n\t\td = dist(pattern,dna)\n\t\tif d < distance:\n\t\t\t# print(pattern,d)\n\t\t\tdistance = d\n\t\t\tmedian = pattern",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.extend(['..','..','data'])\n\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba2b.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba2b.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tk = int(f.readline().strip())\n\t\t\tdna = [x.strip() for x in f.readlines()]\n# Exercise: max possible value of Score(motifs) in terms of t and k (t x k matrix)\n# Max score for one column is given by each nuc being equal, so that 0.75t fail to match\n# This yields a score of k * floor(0.75t)\n# floored because when t%4!=0, one nuc will need to be represented one more time than the others, so we have to round down on the final mismatch score",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\tpath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\tpath = os.path.join(datapath,'rosalind_ba2b.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tk = int(f.readline().strip())\n\t\t\tdna = [x.strip() for x in f.readlines()]\n# Exercise: max possible value of Score(motifs) in terms of t and k (t x k matrix)\n# Max score for one column is given by each nuc being equal, so that 0.75t fail to match\n# This yields a score of k * floor(0.75t)\n# floored because when t%4!=0, one nuc will need to be represented one more time than the others, so we have to round down on the final mismatch score\ndef symbol_to_number(symbol):",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\t\t\tk",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\t\t\tk = int(f.readline().strip())\n\t\t\tdna = [x.strip() for x in f.readlines()]\n# Exercise: max possible value of Score(motifs) in terms of t and k (t x k matrix)\n# Max score for one column is given by each nuc being equal, so that 0.75t fail to match\n# This yields a score of k * floor(0.75t)\n# floored because when t%4!=0, one nuc will need to be represented one more time than the others, so we have to round down on the final mismatch score\ndef symbol_to_number(symbol):\n\treturn {'A':0,'C':1,'G':2,'T':3}[symbol]\ndef pattern_to_number(pattern):\n\tif len(pattern) == 0:",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\t\t\tdna",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\t\t\tdna = [x.strip() for x in f.readlines()]\n# Exercise: max possible value of Score(motifs) in terms of t and k (t x k matrix)\n# Max score for one column is given by each nuc being equal, so that 0.75t fail to match\n# This yields a score of k * floor(0.75t)\n# floored because when t%4!=0, one nuc will need to be represented one more time than the others, so we have to round down on the final mismatch score\ndef symbol_to_number(symbol):\n\treturn {'A':0,'C':1,'G':2,'T':3}[symbol]\ndef pattern_to_number(pattern):\n\tif len(pattern) == 0:\n\t\treturn 0",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\tsymbol",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\tsymbol = pattern[-1]\n\tprefix = pattern[:-1]\n\treturn 4*pattern_to_number(prefix) + symbol_to_number(symbol)\ndef number_to_symbol(number):\n\treturn {0:'A',1:'C',2:'G',3:'T'}[number]\ndef number_to_pattern(index,k):\n\tif k == 1:\n\t\treturn number_to_symbol(index)\n\tprefix_index = index // 4\n\tr = index % 4",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\tprefix",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\tprefix = pattern[:-1]\n\treturn 4*pattern_to_number(prefix) + symbol_to_number(symbol)\ndef number_to_symbol(number):\n\treturn {0:'A',1:'C',2:'G',3:'T'}[number]\ndef number_to_pattern(index,k):\n\tif k == 1:\n\t\treturn number_to_symbol(index)\n\tprefix_index = index // 4\n\tr = index % 4\n\tsymbol = number_to_symbol(r)",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\tprefix_index",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\tprefix_index = index // 4\n\tr = index % 4\n\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\tr",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\tr = index % 4\n\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\tsymbol",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\tsymbol = number_to_symbol(r)\n\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\n# d",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\tprefix_pattern",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\tprefix_pattern = number_to_pattern(prefix_index,k-1)\n\treturn prefix_pattern + symbol\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\n# d\ndef dist(pattern,dna):",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\thamming",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\n# d\ndef dist(pattern,dna):\n\tk = len(pattern)\n\tdistance = 0\n\tfor text in dna:",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\tk",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\tk = len(pattern)\n\tdistance = 0\n\tfor text in dna:\n\t\thamming_dist = 100000\n\t\tfor i in range(len(text)-k+1):\n\t\t\tpattern2 = text[i:i+k]\n\t\t\thamming_dist = min(hamming_dist,hamming_distance(pattern,pattern2))\n\t\tdistance += hamming_dist\n\treturn distance\n# Median string",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\tdistance",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\tdistance = 0\n\tfor text in dna:\n\t\thamming_dist = 100000\n\t\tfor i in range(len(text)-k+1):\n\t\t\tpattern2 = text[i:i+k]\n\t\t\thamming_dist = min(hamming_dist,hamming_distance(pattern,pattern2))\n\t\tdistance += hamming_dist\n\treturn distance\n# Median string\ndef median_string(dna,k):",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\t\thamming_dist",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\t\thamming_dist = 100000\n\t\tfor i in range(len(text)-k+1):\n\t\t\tpattern2 = text[i:i+k]\n\t\t\thamming_dist = min(hamming_dist,hamming_distance(pattern,pattern2))\n\t\tdistance += hamming_dist\n\treturn distance\n# Median string\ndef median_string(dna,k):\n\tdistance = 100000\n\tmedian = ''",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\t\t\tpattern2",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\t\t\tpattern2 = text[i:i+k]\n\t\t\thamming_dist = min(hamming_dist,hamming_distance(pattern,pattern2))\n\t\tdistance += hamming_dist\n\treturn distance\n# Median string\ndef median_string(dna,k):\n\tdistance = 100000\n\tmedian = ''\n\tfor i in range(4**k):\n\t\tpattern = number_to_pattern(i,k)",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\t\t\thamming_dist",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\t\t\thamming_dist = min(hamming_dist,hamming_distance(pattern,pattern2))\n\t\tdistance += hamming_dist\n\treturn distance\n# Median string\ndef median_string(dna,k):\n\tdistance = 100000\n\tmedian = ''\n\tfor i in range(4**k):\n\t\tpattern = number_to_pattern(i,k)\n\t\td = dist(pattern,dna)",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\tdistance",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\tdistance = 100000\n\tmedian = ''\n\tfor i in range(4**k):\n\t\tpattern = number_to_pattern(i,k)\n\t\td = dist(pattern,dna)\n\t\tif d < distance:\n\t\t\t# print(pattern,d)\n\t\t\tdistance = d\n\t\t\tmedian = pattern\n\treturn median",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\tmedian",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\tmedian = ''\n\tfor i in range(4**k):\n\t\tpattern = number_to_pattern(i,k)\n\t\td = dist(pattern,dna)\n\t\tif d < distance:\n\t\t\t# print(pattern,d)\n\t\t\tdistance = d\n\t\t\tmedian = pattern\n\treturn median\n# print(dist('GATTCTCA','GCAAAGACGCTGACCAA'))",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\t\tpattern",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\t\tpattern = number_to_pattern(i,k)\n\t\td = dist(pattern,dna)\n\t\tif d < distance:\n\t\t\t# print(pattern,d)\n\t\t\tdistance = d\n\t\t\tmedian = pattern\n\treturn median\n# print(dist('GATTCTCA','GCAAAGACGCTGACCAA'))\n# print(median_string(['AAATTGACGCAT','GACGACCACGTT','CGTCAGCGCCTG','GCTGAGCACCGG','AGTACGGGACAG'],3))\nprint(median_string(dna,k))",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\t\td",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\t\td = dist(pattern,dna)\n\t\tif d < distance:\n\t\t\t# print(pattern,d)\n\t\t\tdistance = d\n\t\t\tmedian = pattern\n\treturn median\n# print(dist('GATTCTCA','GCAAAGACGCTGACCAA'))\n# print(median_string(['AAATTGACGCAT','GACGACCACGTT','CGTCAGCGCCTG','GCTGAGCACCGG','AGTACGGGACAG'],3))\nprint(median_string(dna,k))",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\t\t\tdistance",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\t\t\tdistance = d\n\t\t\tmedian = pattern\n\treturn median\n# print(dist('GATTCTCA','GCAAAGACGCTGACCAA'))\n# print(median_string(['AAATTGACGCAT','GACGACCACGTT','CGTCAGCGCCTG','GCTGAGCACCGG','AGTACGGGACAG'],3))\nprint(median_string(dna,k))",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "\t\t\tmedian",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2B",
        "description": "textbook.scripts.2.BA2B",
        "peekOfCode": "\t\t\tmedian = pattern\n\treturn median\n# print(dist('GATTCTCA','GCAAAGACGCTGACCAA'))\n# print(median_string(['AAATTGACGCAT','GACGACCACGTT','CGTCAGCGCCTG','GCTGAGCACCGG','AGTACGGGACAG'],3))\nprint(median_string(dna,k))",
        "detail": "textbook.scripts.2.BA2B",
        "documentation": {}
    },
    {
        "label": "probability",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2C",
        "description": "textbook.scripts.2.BA2C",
        "peekOfCode": "def probability(kmer,profile):\n\t#profile is a 4xk matrix\n\tmat_rows = ['A','C','G','T']\n\tk_row = [mat_rows.index(kmer[0])]\n\tprob_n = profile[k_row[0]][0]\n\tif prob_n == 0:\n\t\treturn 0\n\telif len(kmer) == 1:\n\t\treturn prob_n\n\telse:",
        "detail": "textbook.scripts.2.BA2C",
        "documentation": {}
    },
    {
        "label": "profile_most_probable_kmer",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2C",
        "description": "textbook.scripts.2.BA2C",
        "peekOfCode": "def profile_most_probable_kmer(dna,profile):\n\t#profile is a 4xk matrix\n\tk = len(profile[0])\n\tmax_prob = 0\n\tfor kmer in [dna[i:i+k] for i in range(len(dna)-k+1)]:\n\t\tprob = probability(kmer,profile)\n\t\tif prob > max_prob:\n\t\t\tmax_prob = prob\n\t\t\tmax_kmer = kmer\n\treturn max_kmer",
        "detail": "textbook.scripts.2.BA2C",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2C",
        "description": "textbook.scripts.2.BA2C",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.extend(['..','..','data'])\n\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba2c.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:",
        "detail": "textbook.scripts.2.BA2C",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2C",
        "description": "textbook.scripts.2.BA2C",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba2c.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tdna = f.readline().strip()\n\t\t\tk = int(f.readline().strip())\n\t\t\tprofile = []\n\t\t\tfor line in f:\n\t\t\t\tprofile.append([float(i) for i in line.strip().split()])\ndef probability(kmer,profile):",
        "detail": "textbook.scripts.2.BA2C",
        "documentation": {}
    },
    {
        "label": "\tpath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2C",
        "description": "textbook.scripts.2.BA2C",
        "peekOfCode": "\tpath = os.path.join(datapath,'rosalind_ba2c.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tdna = f.readline().strip()\n\t\t\tk = int(f.readline().strip())\n\t\t\tprofile = []\n\t\t\tfor line in f:\n\t\t\t\tprofile.append([float(i) for i in line.strip().split()])\ndef probability(kmer,profile):\n\t#profile is a 4xk matrix",
        "detail": "textbook.scripts.2.BA2C",
        "documentation": {}
    },
    {
        "label": "\t\t\tdna",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2C",
        "description": "textbook.scripts.2.BA2C",
        "peekOfCode": "\t\t\tdna = f.readline().strip()\n\t\t\tk = int(f.readline().strip())\n\t\t\tprofile = []\n\t\t\tfor line in f:\n\t\t\t\tprofile.append([float(i) for i in line.strip().split()])\ndef probability(kmer,profile):\n\t#profile is a 4xk matrix\n\tmat_rows = ['A','C','G','T']\n\tk_row = [mat_rows.index(kmer[0])]\n\tprob_n = profile[k_row[0]][0]",
        "detail": "textbook.scripts.2.BA2C",
        "documentation": {}
    },
    {
        "label": "\t\t\tk",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2C",
        "description": "textbook.scripts.2.BA2C",
        "peekOfCode": "\t\t\tk = int(f.readline().strip())\n\t\t\tprofile = []\n\t\t\tfor line in f:\n\t\t\t\tprofile.append([float(i) for i in line.strip().split()])\ndef probability(kmer,profile):\n\t#profile is a 4xk matrix\n\tmat_rows = ['A','C','G','T']\n\tk_row = [mat_rows.index(kmer[0])]\n\tprob_n = profile[k_row[0]][0]\n\tif prob_n == 0:",
        "detail": "textbook.scripts.2.BA2C",
        "documentation": {}
    },
    {
        "label": "\t\t\tprofile",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2C",
        "description": "textbook.scripts.2.BA2C",
        "peekOfCode": "\t\t\tprofile = []\n\t\t\tfor line in f:\n\t\t\t\tprofile.append([float(i) for i in line.strip().split()])\ndef probability(kmer,profile):\n\t#profile is a 4xk matrix\n\tmat_rows = ['A','C','G','T']\n\tk_row = [mat_rows.index(kmer[0])]\n\tprob_n = profile[k_row[0]][0]\n\tif prob_n == 0:\n\t\treturn 0",
        "detail": "textbook.scripts.2.BA2C",
        "documentation": {}
    },
    {
        "label": "\tmat_rows",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2C",
        "description": "textbook.scripts.2.BA2C",
        "peekOfCode": "\tmat_rows = ['A','C','G','T']\n\tk_row = [mat_rows.index(kmer[0])]\n\tprob_n = profile[k_row[0]][0]\n\tif prob_n == 0:\n\t\treturn 0\n\telif len(kmer) == 1:\n\t\treturn prob_n\n\telse:\n\t\treturn prob_n * probability(kmer[1:],[profile[i][1:] for i in range(4)])\ndef profile_most_probable_kmer(dna,profile):",
        "detail": "textbook.scripts.2.BA2C",
        "documentation": {}
    },
    {
        "label": "\tk_row",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2C",
        "description": "textbook.scripts.2.BA2C",
        "peekOfCode": "\tk_row = [mat_rows.index(kmer[0])]\n\tprob_n = profile[k_row[0]][0]\n\tif prob_n == 0:\n\t\treturn 0\n\telif len(kmer) == 1:\n\t\treturn prob_n\n\telse:\n\t\treturn prob_n * probability(kmer[1:],[profile[i][1:] for i in range(4)])\ndef profile_most_probable_kmer(dna,profile):\n\t#profile is a 4xk matrix",
        "detail": "textbook.scripts.2.BA2C",
        "documentation": {}
    },
    {
        "label": "\tprob_n",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2C",
        "description": "textbook.scripts.2.BA2C",
        "peekOfCode": "\tprob_n = profile[k_row[0]][0]\n\tif prob_n == 0:\n\t\treturn 0\n\telif len(kmer) == 1:\n\t\treturn prob_n\n\telse:\n\t\treturn prob_n * probability(kmer[1:],[profile[i][1:] for i in range(4)])\ndef profile_most_probable_kmer(dna,profile):\n\t#profile is a 4xk matrix\n\tk = len(profile[0])",
        "detail": "textbook.scripts.2.BA2C",
        "documentation": {}
    },
    {
        "label": "\tk",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2C",
        "description": "textbook.scripts.2.BA2C",
        "peekOfCode": "\tk = len(profile[0])\n\tmax_prob = 0\n\tfor kmer in [dna[i:i+k] for i in range(len(dna)-k+1)]:\n\t\tprob = probability(kmer,profile)\n\t\tif prob > max_prob:\n\t\t\tmax_prob = prob\n\t\t\tmax_kmer = kmer\n\treturn max_kmer\n# print(profile_most_probable_kmer('ACCTGTTTATTGCCTAAGTTCCGAACAAACCCAATATAGCCCGAGGGCCT',[[0.2,0.2,0.3,0.2,0.3],[0.4,0.3,0.1,0.5,0.1],[0.3,0.3,0.5,0.2,0.4],[0.1,0.2,0.1,0.1,0.2]]))\nprint(profile_most_probable_kmer(dna,profile))",
        "detail": "textbook.scripts.2.BA2C",
        "documentation": {}
    },
    {
        "label": "\tmax_prob",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2C",
        "description": "textbook.scripts.2.BA2C",
        "peekOfCode": "\tmax_prob = 0\n\tfor kmer in [dna[i:i+k] for i in range(len(dna)-k+1)]:\n\t\tprob = probability(kmer,profile)\n\t\tif prob > max_prob:\n\t\t\tmax_prob = prob\n\t\t\tmax_kmer = kmer\n\treturn max_kmer\n# print(profile_most_probable_kmer('ACCTGTTTATTGCCTAAGTTCCGAACAAACCCAATATAGCCCGAGGGCCT',[[0.2,0.2,0.3,0.2,0.3],[0.4,0.3,0.1,0.5,0.1],[0.3,0.3,0.5,0.2,0.4],[0.1,0.2,0.1,0.1,0.2]]))\nprint(profile_most_probable_kmer(dna,profile))",
        "detail": "textbook.scripts.2.BA2C",
        "documentation": {}
    },
    {
        "label": "\t\tprob",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2C",
        "description": "textbook.scripts.2.BA2C",
        "peekOfCode": "\t\tprob = probability(kmer,profile)\n\t\tif prob > max_prob:\n\t\t\tmax_prob = prob\n\t\t\tmax_kmer = kmer\n\treturn max_kmer\n# print(profile_most_probable_kmer('ACCTGTTTATTGCCTAAGTTCCGAACAAACCCAATATAGCCCGAGGGCCT',[[0.2,0.2,0.3,0.2,0.3],[0.4,0.3,0.1,0.5,0.1],[0.3,0.3,0.5,0.2,0.4],[0.1,0.2,0.1,0.1,0.2]]))\nprint(profile_most_probable_kmer(dna,profile))",
        "detail": "textbook.scripts.2.BA2C",
        "documentation": {}
    },
    {
        "label": "\t\t\tmax_prob",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2C",
        "description": "textbook.scripts.2.BA2C",
        "peekOfCode": "\t\t\tmax_prob = prob\n\t\t\tmax_kmer = kmer\n\treturn max_kmer\n# print(profile_most_probable_kmer('ACCTGTTTATTGCCTAAGTTCCGAACAAACCCAATATAGCCCGAGGGCCT',[[0.2,0.2,0.3,0.2,0.3],[0.4,0.3,0.1,0.5,0.1],[0.3,0.3,0.5,0.2,0.4],[0.1,0.2,0.1,0.1,0.2]]))\nprint(profile_most_probable_kmer(dna,profile))",
        "detail": "textbook.scripts.2.BA2C",
        "documentation": {}
    },
    {
        "label": "\t\t\tmax_kmer",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2C",
        "description": "textbook.scripts.2.BA2C",
        "peekOfCode": "\t\t\tmax_kmer = kmer\n\treturn max_kmer\n# print(profile_most_probable_kmer('ACCTGTTTATTGCCTAAGTTCCGAACAAACCCAATATAGCCCGAGGGCCT',[[0.2,0.2,0.3,0.2,0.3],[0.4,0.3,0.1,0.5,0.1],[0.3,0.3,0.5,0.2,0.4],[0.1,0.2,0.1,0.1,0.2]]))\nprint(profile_most_probable_kmer(dna,profile))",
        "detail": "textbook.scripts.2.BA2C",
        "documentation": {}
    },
    {
        "label": "probability",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2D",
        "description": "textbook.scripts.2.BA2D",
        "peekOfCode": "def probability(kmer,profile):\n    #profile is a 4xk matrix\n    mat_rows = ['A','C','G','T']\n    prob_n = 1\n    for i in range(len(kmer)):\n        prob_n *= profile[mat_rows.index(kmer[i])][i]\n    return prob_n\ndef profile_most_probable_kmer(dna,profile,k):\n    #profile is a 4xk matrix\n    max_prob = 0",
        "detail": "textbook.scripts.2.BA2D",
        "documentation": {}
    },
    {
        "label": "profile_most_probable_kmer",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2D",
        "description": "textbook.scripts.2.BA2D",
        "peekOfCode": "def profile_most_probable_kmer(dna,profile,k):\n    #profile is a 4xk matrix\n    max_prob = 0\n    max_kmer = ''\n    for i in range(len(dna)-k+1):\n        kmer = dna[i:i+k]\n        prob = probability(kmer,profile)\n        if prob > max_prob or max_kmer == '':\n            max_prob = prob\n            max_kmer = kmer",
        "detail": "textbook.scripts.2.BA2D",
        "documentation": {}
    },
    {
        "label": "make_profile",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2D",
        "description": "textbook.scripts.2.BA2D",
        "peekOfCode": "def make_profile(dna,k,start):\n    mat_rows = ['A','C','G','T']\n    profile = [[],[],[],[]]\n    for i in range(start,start+k):\n        kth_nucs = [dna[j][i] for j in range(len(dna)) if len(dna[j]) > i]\n        counts = [kth_nucs.count(nuc) for nuc in mat_rows]\n        sum_counts = sum(counts)\n        probs = [count/sum_counts if sum_counts != 0 else 0 for count in counts]\n        for j in range(len(probs)):\n            profile[j].append(probs[j])",
        "detail": "textbook.scripts.2.BA2D",
        "documentation": {}
    },
    {
        "label": "get_motifs",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2D",
        "description": "textbook.scripts.2.BA2D",
        "peekOfCode": "def get_motifs(dna,k,n):\n\treturn [dna_i[n:n+k] for dna_i in dna]\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef score(motifs):\n\tconsensus = ''",
        "detail": "textbook.scripts.2.BA2D",
        "documentation": {}
    },
    {
        "label": "hamming_distance",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2D",
        "description": "textbook.scripts.2.BA2D",
        "peekOfCode": "def hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef score(motifs):\n\tconsensus = ''\n\tfor i in range(len(motifs[0])):\n\t\tnucs = [motifs[j][i] for j in range(len(motifs))]",
        "detail": "textbook.scripts.2.BA2D",
        "documentation": {}
    },
    {
        "label": "score",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2D",
        "description": "textbook.scripts.2.BA2D",
        "peekOfCode": "def score(motifs):\n\tconsensus = ''\n\tfor i in range(len(motifs[0])):\n\t\tnucs = [motifs[j][i] for j in range(len(motifs))]\n\t\tconsensus += max(set(nucs),key=nucs.count)\n\tscore = 0\n\tfor motif in motifs:\n\t\tscore += hamming_distance(motif,consensus)\n\treturn score\ndef greedy_motif_search(dna,k,t):",
        "detail": "textbook.scripts.2.BA2D",
        "documentation": {}
    },
    {
        "label": "greedy_motif_search",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2D",
        "description": "textbook.scripts.2.BA2D",
        "peekOfCode": "def greedy_motif_search(dna,k,t):\n    best_motifs = [dna_i[0:k] for dna_i in dna]\n    for i in range(len(dna[0])-k+1):\n        motif = dna[0][i:i+k]\n        motifs = [motif]\n        for j in range(1,t):\n            profile = make_profile(motifs,k,0)\n            motifs.append(profile_most_probable_kmer(dna[j],profile,k))\n        if score(motifs) < score(best_motifs):\n            best_motifs = motifs",
        "detail": "textbook.scripts.2.BA2D",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2D",
        "description": "textbook.scripts.2.BA2D",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.extend(['..','..','data'])\n\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba2d.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:",
        "detail": "textbook.scripts.2.BA2D",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2D",
        "description": "textbook.scripts.2.BA2D",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba2d.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tk,t = [int(x) for x in f.readline().strip().split()]\n\t\t\tdna = [line.strip() for line in f.readlines()]\ndef probability(kmer,profile):\n    #profile is a 4xk matrix\n    mat_rows = ['A','C','G','T']\n    prob_n = 1",
        "detail": "textbook.scripts.2.BA2D",
        "documentation": {}
    },
    {
        "label": "\tpath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2D",
        "description": "textbook.scripts.2.BA2D",
        "peekOfCode": "\tpath = os.path.join(datapath,'rosalind_ba2d.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tk,t = [int(x) for x in f.readline().strip().split()]\n\t\t\tdna = [line.strip() for line in f.readlines()]\ndef probability(kmer,profile):\n    #profile is a 4xk matrix\n    mat_rows = ['A','C','G','T']\n    prob_n = 1\n    for i in range(len(kmer)):",
        "detail": "textbook.scripts.2.BA2D",
        "documentation": {}
    },
    {
        "label": "\t\t\tk,t",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2D",
        "description": "textbook.scripts.2.BA2D",
        "peekOfCode": "\t\t\tk,t = [int(x) for x in f.readline().strip().split()]\n\t\t\tdna = [line.strip() for line in f.readlines()]\ndef probability(kmer,profile):\n    #profile is a 4xk matrix\n    mat_rows = ['A','C','G','T']\n    prob_n = 1\n    for i in range(len(kmer)):\n        prob_n *= profile[mat_rows.index(kmer[i])][i]\n    return prob_n\ndef profile_most_probable_kmer(dna,profile,k):",
        "detail": "textbook.scripts.2.BA2D",
        "documentation": {}
    },
    {
        "label": "\t\t\tdna",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2D",
        "description": "textbook.scripts.2.BA2D",
        "peekOfCode": "\t\t\tdna = [line.strip() for line in f.readlines()]\ndef probability(kmer,profile):\n    #profile is a 4xk matrix\n    mat_rows = ['A','C','G','T']\n    prob_n = 1\n    for i in range(len(kmer)):\n        prob_n *= profile[mat_rows.index(kmer[i])][i]\n    return prob_n\ndef profile_most_probable_kmer(dna,profile,k):\n    #profile is a 4xk matrix",
        "detail": "textbook.scripts.2.BA2D",
        "documentation": {}
    },
    {
        "label": "\thamming",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2D",
        "description": "textbook.scripts.2.BA2D",
        "peekOfCode": "\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef score(motifs):\n\tconsensus = ''\n\tfor i in range(len(motifs[0])):\n\t\tnucs = [motifs[j][i] for j in range(len(motifs))]\n\t\tconsensus += max(set(nucs),key=nucs.count)",
        "detail": "textbook.scripts.2.BA2D",
        "documentation": {}
    },
    {
        "label": "\tconsensus",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2D",
        "description": "textbook.scripts.2.BA2D",
        "peekOfCode": "\tconsensus = ''\n\tfor i in range(len(motifs[0])):\n\t\tnucs = [motifs[j][i] for j in range(len(motifs))]\n\t\tconsensus += max(set(nucs),key=nucs.count)\n\tscore = 0\n\tfor motif in motifs:\n\t\tscore += hamming_distance(motif,consensus)\n\treturn score\ndef greedy_motif_search(dna,k,t):\n    best_motifs = [dna_i[0:k] for dna_i in dna]",
        "detail": "textbook.scripts.2.BA2D",
        "documentation": {}
    },
    {
        "label": "\t\tnucs",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2D",
        "description": "textbook.scripts.2.BA2D",
        "peekOfCode": "\t\tnucs = [motifs[j][i] for j in range(len(motifs))]\n\t\tconsensus += max(set(nucs),key=nucs.count)\n\tscore = 0\n\tfor motif in motifs:\n\t\tscore += hamming_distance(motif,consensus)\n\treturn score\ndef greedy_motif_search(dna,k,t):\n    best_motifs = [dna_i[0:k] for dna_i in dna]\n    for i in range(len(dna[0])-k+1):\n        motif = dna[0][i:i+k]",
        "detail": "textbook.scripts.2.BA2D",
        "documentation": {}
    },
    {
        "label": "\tscore",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2D",
        "description": "textbook.scripts.2.BA2D",
        "peekOfCode": "\tscore = 0\n\tfor motif in motifs:\n\t\tscore += hamming_distance(motif,consensus)\n\treturn score\ndef greedy_motif_search(dna,k,t):\n    best_motifs = [dna_i[0:k] for dna_i in dna]\n    for i in range(len(dna[0])-k+1):\n        motif = dna[0][i:i+k]\n        motifs = [motif]\n        for j in range(1,t):",
        "detail": "textbook.scripts.2.BA2D",
        "documentation": {}
    },
    {
        "label": "probability",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2E",
        "description": "textbook.scripts.2.BA2E",
        "peekOfCode": "def probability(kmer,profile):\n    #profile is a 4xk matrix\n    mat_rows = ['A','C','G','T']\n    prob_n = 1\n    for i in range(len(kmer)):\n        prob_n *= profile[mat_rows.index(kmer[i])][i]\n    return prob_n\ndef profile_most_probable_kmer(dna,profile,k):\n    #profile is a 4xk matrix\n    max_prob = 0",
        "detail": "textbook.scripts.2.BA2E",
        "documentation": {}
    },
    {
        "label": "profile_most_probable_kmer",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2E",
        "description": "textbook.scripts.2.BA2E",
        "peekOfCode": "def profile_most_probable_kmer(dna,profile,k):\n    #profile is a 4xk matrix\n    max_prob = 0\n    max_kmer = ''\n    for i in range(len(dna)-k+1):\n        kmer = dna[i:i+k]\n        prob = probability(kmer,profile)\n        if prob > max_prob or max_kmer == '':\n            max_prob = prob\n            max_kmer = kmer",
        "detail": "textbook.scripts.2.BA2E",
        "documentation": {}
    },
    {
        "label": "make_profile_laplace",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2E",
        "description": "textbook.scripts.2.BA2E",
        "peekOfCode": "def make_profile_laplace(dna,k,start):\n    mat_rows = ['A','C','G','T']\n    profile = [[],[],[],[]]\n    for i in range(start,start+k):\n        kth_nucs = [dna[j][i] for j in range(len(dna)) if len(dna[j]) > i]\n        counts = [kth_nucs.count(nuc)+1 for nuc in mat_rows]\n        sum_counts = sum(counts)\n        probs = [count/sum_counts if sum_counts != 0 else 0 for count in counts]\n        for j in range(len(probs)):\n            profile[j].append(probs[j])",
        "detail": "textbook.scripts.2.BA2E",
        "documentation": {}
    },
    {
        "label": "get_motifs",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2E",
        "description": "textbook.scripts.2.BA2E",
        "peekOfCode": "def get_motifs(dna,k,n):\n\treturn [dna_i[n:n+k] for dna_i in dna]\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef score(motifs):\n\tconsensus = ''",
        "detail": "textbook.scripts.2.BA2E",
        "documentation": {}
    },
    {
        "label": "hamming_distance",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2E",
        "description": "textbook.scripts.2.BA2E",
        "peekOfCode": "def hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef score(motifs):\n\tconsensus = ''\n\tfor i in range(len(motifs[0])):\n\t\tnucs = [motifs[j][i] for j in range(len(motifs))]",
        "detail": "textbook.scripts.2.BA2E",
        "documentation": {}
    },
    {
        "label": "score",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2E",
        "description": "textbook.scripts.2.BA2E",
        "peekOfCode": "def score(motifs):\n\tconsensus = ''\n\tfor i in range(len(motifs[0])):\n\t\tnucs = [motifs[j][i] for j in range(len(motifs))]\n\t\tconsensus += max(set(nucs),key=nucs.count)\n\tscore = 0\n\tfor motif in motifs:\n\t\tscore += hamming_distance(motif,consensus)\n\treturn score\ndef greedy_motif_search_with_laplace(dna,k,t):",
        "detail": "textbook.scripts.2.BA2E",
        "documentation": {}
    },
    {
        "label": "greedy_motif_search_with_laplace",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2E",
        "description": "textbook.scripts.2.BA2E",
        "peekOfCode": "def greedy_motif_search_with_laplace(dna,k,t):\n    best_motifs = [dna_i[0:k] for dna_i in dna]\n    for i in range(len(dna[0])-k+1):\n        motif = dna[0][i:i+k]\n        motifs = [motif]\n        for j in range(1,t):\n            profile = make_profile_laplace(motifs,k,0)\n            motifs.append(profile_most_probable_kmer(dna[j],profile,k))\n        if score(motifs) < score(best_motifs):\n            best_motifs = motifs",
        "detail": "textbook.scripts.2.BA2E",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2E",
        "description": "textbook.scripts.2.BA2E",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.extend(['..','..','data'])\n\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba2e.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:",
        "detail": "textbook.scripts.2.BA2E",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2E",
        "description": "textbook.scripts.2.BA2E",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba2e.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tk,t = [int(x) for x in f.readline().strip().split()]\n\t\t\tdna = [line.strip() for line in f.readlines()]\ndef probability(kmer,profile):\n    #profile is a 4xk matrix\n    mat_rows = ['A','C','G','T']\n    prob_n = 1",
        "detail": "textbook.scripts.2.BA2E",
        "documentation": {}
    },
    {
        "label": "\tpath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2E",
        "description": "textbook.scripts.2.BA2E",
        "peekOfCode": "\tpath = os.path.join(datapath,'rosalind_ba2e.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tk,t = [int(x) for x in f.readline().strip().split()]\n\t\t\tdna = [line.strip() for line in f.readlines()]\ndef probability(kmer,profile):\n    #profile is a 4xk matrix\n    mat_rows = ['A','C','G','T']\n    prob_n = 1\n    for i in range(len(kmer)):",
        "detail": "textbook.scripts.2.BA2E",
        "documentation": {}
    },
    {
        "label": "\t\t\tk,t",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2E",
        "description": "textbook.scripts.2.BA2E",
        "peekOfCode": "\t\t\tk,t = [int(x) for x in f.readline().strip().split()]\n\t\t\tdna = [line.strip() for line in f.readlines()]\ndef probability(kmer,profile):\n    #profile is a 4xk matrix\n    mat_rows = ['A','C','G','T']\n    prob_n = 1\n    for i in range(len(kmer)):\n        prob_n *= profile[mat_rows.index(kmer[i])][i]\n    return prob_n\ndef profile_most_probable_kmer(dna,profile,k):",
        "detail": "textbook.scripts.2.BA2E",
        "documentation": {}
    },
    {
        "label": "\t\t\tdna",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2E",
        "description": "textbook.scripts.2.BA2E",
        "peekOfCode": "\t\t\tdna = [line.strip() for line in f.readlines()]\ndef probability(kmer,profile):\n    #profile is a 4xk matrix\n    mat_rows = ['A','C','G','T']\n    prob_n = 1\n    for i in range(len(kmer)):\n        prob_n *= profile[mat_rows.index(kmer[i])][i]\n    return prob_n\ndef profile_most_probable_kmer(dna,profile,k):\n    #profile is a 4xk matrix",
        "detail": "textbook.scripts.2.BA2E",
        "documentation": {}
    },
    {
        "label": "\thamming",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2E",
        "description": "textbook.scripts.2.BA2E",
        "peekOfCode": "\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef score(motifs):\n\tconsensus = ''\n\tfor i in range(len(motifs[0])):\n\t\tnucs = [motifs[j][i] for j in range(len(motifs))]\n\t\tconsensus += max(set(nucs),key=nucs.count)",
        "detail": "textbook.scripts.2.BA2E",
        "documentation": {}
    },
    {
        "label": "\tconsensus",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2E",
        "description": "textbook.scripts.2.BA2E",
        "peekOfCode": "\tconsensus = ''\n\tfor i in range(len(motifs[0])):\n\t\tnucs = [motifs[j][i] for j in range(len(motifs))]\n\t\tconsensus += max(set(nucs),key=nucs.count)\n\tscore = 0\n\tfor motif in motifs:\n\t\tscore += hamming_distance(motif,consensus)\n\treturn score\ndef greedy_motif_search_with_laplace(dna,k,t):\n    best_motifs = [dna_i[0:k] for dna_i in dna]",
        "detail": "textbook.scripts.2.BA2E",
        "documentation": {}
    },
    {
        "label": "\t\tnucs",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2E",
        "description": "textbook.scripts.2.BA2E",
        "peekOfCode": "\t\tnucs = [motifs[j][i] for j in range(len(motifs))]\n\t\tconsensus += max(set(nucs),key=nucs.count)\n\tscore = 0\n\tfor motif in motifs:\n\t\tscore += hamming_distance(motif,consensus)\n\treturn score\ndef greedy_motif_search_with_laplace(dna,k,t):\n    best_motifs = [dna_i[0:k] for dna_i in dna]\n    for i in range(len(dna[0])-k+1):\n        motif = dna[0][i:i+k]",
        "detail": "textbook.scripts.2.BA2E",
        "documentation": {}
    },
    {
        "label": "\tscore",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2E",
        "description": "textbook.scripts.2.BA2E",
        "peekOfCode": "\tscore = 0\n\tfor motif in motifs:\n\t\tscore += hamming_distance(motif,consensus)\n\treturn score\ndef greedy_motif_search_with_laplace(dna,k,t):\n    best_motifs = [dna_i[0:k] for dna_i in dna]\n    for i in range(len(dna[0])-k+1):\n        motif = dna[0][i:i+k]\n        motifs = [motif]\n        for j in range(1,t):",
        "detail": "textbook.scripts.2.BA2E",
        "documentation": {}
    },
    {
        "label": "hamming_distance",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "def hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef score(motifs):\n\tconsensus = ''\n\tfor i in range(len(motifs[0])):\n\t\tnucs = [motifs[j][i] for j in range(len(motifs))]",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "score",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "def score(motifs):\n\tconsensus = ''\n\tfor i in range(len(motifs[0])):\n\t\tnucs = [motifs[j][i] for j in range(len(motifs))]\n\t\tconsensus += max(set(nucs),key=nucs.count)\n\tscore = 0\n\tfor motif in motifs:\n\t\tscore += hamming_distance(motif,consensus)\n\treturn score\ndef make_profile_laplace(dna,k,start):",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "make_profile_laplace",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "def make_profile_laplace(dna,k,start):\n    mat_rows = ['A','C','G','T']\n    profile = [[],[],[],[]]\n    for i in range(start,start+k):\n        kth_nucs = [dna[j][i] for j in range(len(dna)) if len(dna[j]) > i]\n        counts = [kth_nucs.count(nuc)+1 for nuc in mat_rows]\n        sum_counts = sum(counts)\n        probs = [count/sum_counts if sum_counts != 0 else 0 for count in counts]\n        for j in range(len(probs)):\n            profile[j].append(probs[j])",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "probability",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "def probability(kmer,profile):\n    #profile is a 4xk matrix\n    mat_rows = ['A','C','G','T']\n    prob_n = 1\n    for i in range(len(kmer)):\n        prob_n *= profile[mat_rows.index(kmer[i])][i]\n    return prob_n\ndef profile_most_probable_kmer(dna,profile,k):\n    #profile is a 4xk matrix\n    max_prob = 0",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "profile_most_probable_kmer",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "def profile_most_probable_kmer(dna,profile,k):\n    #profile is a 4xk matrix\n    max_prob = 0\n    max_kmer = ''\n    for i in range(len(dna)-k+1):\n        kmer = dna[i:i+k]\n        prob = probability(kmer,profile)\n        if prob > max_prob or max_kmer == '':\n            max_prob = prob\n            max_kmer = kmer",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "randomized_motif_search",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "def randomized_motif_search(dna,k,t):\n\tmotifs = []\n\tfor i in range(t):\n\t\tstart = random.randint(0,len(dna[i])-k)\n\t\tmotifs.append(dna[i][start:start+k])\n\tbest_motifs = motifs\n\twhile True:\n\t\tprofile = make_profile_laplace(motifs,k,0)\n\t\tmotifs = [profile_most_probable_kmer(dna[i],profile,k) for i in range(t)]\n\t\tif score(motifs) < score(best_motifs):",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.extend(['..','..','data'])\n\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba2f.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba2f.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tk,t = [int(x) for x in f.readline().strip().split()]\n\t\t\tdna = [line.strip() for line in f.readlines()]\nimport random\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "\tpath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "\tpath = os.path.join(datapath,'rosalind_ba2f.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tk,t = [int(x) for x in f.readline().strip().split()]\n\t\t\tdna = [line.strip() for line in f.readlines()]\nimport random\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "\t\t\tk,t",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "\t\t\tk,t = [int(x) for x in f.readline().strip().split()]\n\t\t\tdna = [line.strip() for line in f.readlines()]\nimport random\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef score(motifs):",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "\t\t\tdna",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "\t\t\tdna = [line.strip() for line in f.readlines()]\nimport random\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef score(motifs):\n\tconsensus = ''",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "\thamming",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef score(motifs):\n\tconsensus = ''\n\tfor i in range(len(motifs[0])):\n\t\tnucs = [motifs[j][i] for j in range(len(motifs))]\n\t\tconsensus += max(set(nucs),key=nucs.count)",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "\tconsensus",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "\tconsensus = ''\n\tfor i in range(len(motifs[0])):\n\t\tnucs = [motifs[j][i] for j in range(len(motifs))]\n\t\tconsensus += max(set(nucs),key=nucs.count)\n\tscore = 0\n\tfor motif in motifs:\n\t\tscore += hamming_distance(motif,consensus)\n\treturn score\ndef make_profile_laplace(dna,k,start):\n    mat_rows = ['A','C','G','T']",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "\t\tnucs",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "\t\tnucs = [motifs[j][i] for j in range(len(motifs))]\n\t\tconsensus += max(set(nucs),key=nucs.count)\n\tscore = 0\n\tfor motif in motifs:\n\t\tscore += hamming_distance(motif,consensus)\n\treturn score\ndef make_profile_laplace(dna,k,start):\n    mat_rows = ['A','C','G','T']\n    profile = [[],[],[],[]]\n    for i in range(start,start+k):",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "\tscore",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "\tscore = 0\n\tfor motif in motifs:\n\t\tscore += hamming_distance(motif,consensus)\n\treturn score\ndef make_profile_laplace(dna,k,start):\n    mat_rows = ['A','C','G','T']\n    profile = [[],[],[],[]]\n    for i in range(start,start+k):\n        kth_nucs = [dna[j][i] for j in range(len(dna)) if len(dna[j]) > i]\n        counts = [kth_nucs.count(nuc)+1 for nuc in mat_rows]",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "\tmotifs",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "\tmotifs = []\n\tfor i in range(t):\n\t\tstart = random.randint(0,len(dna[i])-k)\n\t\tmotifs.append(dna[i][start:start+k])\n\tbest_motifs = motifs\n\twhile True:\n\t\tprofile = make_profile_laplace(motifs,k,0)\n\t\tmotifs = [profile_most_probable_kmer(dna[i],profile,k) for i in range(t)]\n\t\tif score(motifs) < score(best_motifs):\n\t\t\tbest_motifs = motifs",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "\t\tstart",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "\t\tstart = random.randint(0,len(dna[i])-k)\n\t\tmotifs.append(dna[i][start:start+k])\n\tbest_motifs = motifs\n\twhile True:\n\t\tprofile = make_profile_laplace(motifs,k,0)\n\t\tmotifs = [profile_most_probable_kmer(dna[i],profile,k) for i in range(t)]\n\t\tif score(motifs) < score(best_motifs):\n\t\t\tbest_motifs = motifs\n\t\telse:\n\t\t\treturn best_motifs, score(best_motifs)",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "\tbest_motifs",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "\tbest_motifs = motifs\n\twhile True:\n\t\tprofile = make_profile_laplace(motifs,k,0)\n\t\tmotifs = [profile_most_probable_kmer(dna[i],profile,k) for i in range(t)]\n\t\tif score(motifs) < score(best_motifs):\n\t\t\tbest_motifs = motifs\n\t\telse:\n\t\t\treturn best_motifs, score(best_motifs)\nbest_score = 100000000\nbest_motifs = []",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "\t\tprofile",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "\t\tprofile = make_profile_laplace(motifs,k,0)\n\t\tmotifs = [profile_most_probable_kmer(dna[i],profile,k) for i in range(t)]\n\t\tif score(motifs) < score(best_motifs):\n\t\t\tbest_motifs = motifs\n\t\telse:\n\t\t\treturn best_motifs, score(best_motifs)\nbest_score = 100000000\nbest_motifs = []\nfor i in range(1000):\n\t# motif_results, score_result = randomized_motif_search(['CGCCCCTCTCGGGGGTGTTCAGTAAACGGCCA','GGGCGAGGTATGTGTAAGTGCCAAGGTGCCAG',",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "\t\tmotifs",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "\t\tmotifs = [profile_most_probable_kmer(dna[i],profile,k) for i in range(t)]\n\t\tif score(motifs) < score(best_motifs):\n\t\t\tbest_motifs = motifs\n\t\telse:\n\t\t\treturn best_motifs, score(best_motifs)\nbest_score = 100000000\nbest_motifs = []\nfor i in range(1000):\n\t# motif_results, score_result = randomized_motif_search(['CGCCCCTCTCGGGGGTGTTCAGTAAACGGCCA','GGGCGAGGTATGTGTAAGTGCCAAGGTGCCAG',\n\t# 'TAGTACCGAGACCGAAAGAAGTATACAGGCGT','TAGATCAAGTTTCAGGTGCACGTCGGTGAACC',",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "\t\t\tbest_motifs",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "\t\t\tbest_motifs = motifs\n\t\telse:\n\t\t\treturn best_motifs, score(best_motifs)\nbest_score = 100000000\nbest_motifs = []\nfor i in range(1000):\n\t# motif_results, score_result = randomized_motif_search(['CGCCCCTCTCGGGGGTGTTCAGTAAACGGCCA','GGGCGAGGTATGTGTAAGTGCCAAGGTGCCAG',\n\t# 'TAGTACCGAGACCGAAAGAAGTATACAGGCGT','TAGATCAAGTTTCAGGTGCACGTCGGTGAACC',\n\t# 'AATCCACCAGCTCCACGTGCAATGTTGGCCTA'],8,5)\n\tmotif_results, score_result = randomized_motif_search(dna,k,t)",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "best_score",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "best_score = 100000000\nbest_motifs = []\nfor i in range(1000):\n\t# motif_results, score_result = randomized_motif_search(['CGCCCCTCTCGGGGGTGTTCAGTAAACGGCCA','GGGCGAGGTATGTGTAAGTGCCAAGGTGCCAG',\n\t# 'TAGTACCGAGACCGAAAGAAGTATACAGGCGT','TAGATCAAGTTTCAGGTGCACGTCGGTGAACC',\n\t# 'AATCCACCAGCTCCACGTGCAATGTTGGCCTA'],8,5)\n\tmotif_results, score_result = randomized_motif_search(dna,k,t)\n\tif score_result < best_score:\n\t\tbest_score = score_result\n\t\tbest_motifs = motif_results",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "best_motifs",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "best_motifs = []\nfor i in range(1000):\n\t# motif_results, score_result = randomized_motif_search(['CGCCCCTCTCGGGGGTGTTCAGTAAACGGCCA','GGGCGAGGTATGTGTAAGTGCCAAGGTGCCAG',\n\t# 'TAGTACCGAGACCGAAAGAAGTATACAGGCGT','TAGATCAAGTTTCAGGTGCACGTCGGTGAACC',\n\t# 'AATCCACCAGCTCCACGTGCAATGTTGGCCTA'],8,5)\n\tmotif_results, score_result = randomized_motif_search(dna,k,t)\n\tif score_result < best_score:\n\t\tbest_score = score_result\n\t\tbest_motifs = motif_results\n# print(best_score)",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "\t\tbest_score",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "\t\tbest_score = score_result\n\t\tbest_motifs = motif_results\n# print(best_score)\nfor motif in best_motifs:\n\tprint(motif)",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "\t\tbest_motifs",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2F",
        "description": "textbook.scripts.2.BA2F",
        "peekOfCode": "\t\tbest_motifs = motif_results\n# print(best_score)\nfor motif in best_motifs:\n\tprint(motif)",
        "detail": "textbook.scripts.2.BA2F",
        "documentation": {}
    },
    {
        "label": "hamming_distance",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "def hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef score(motifs):\n\tconsensus = ''\n\tfor i in range(len(motifs[0])):\n\t\tnucs = [motifs[j][i] for j in range(len(motifs))]",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "score",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "def score(motifs):\n\tconsensus = ''\n\tfor i in range(len(motifs[0])):\n\t\tnucs = [motifs[j][i] for j in range(len(motifs))]\n\t\tconsensus += max(set(nucs),key=nucs.count)\n\tscore = 0\n\tfor motif in motifs:\n\t\tscore += hamming_distance(motif,consensus)\n\treturn score\ndef make_profile_laplace_gibbs(dna,k,start,i):",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "make_profile_laplace_gibbs",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "def make_profile_laplace_gibbs(dna,k,start,i):\n    mat_rows = ['A','C','G','T']\n    profile = [[],[],[],[]]\n    for i in range(start,start+k):\n        kth_nucs = [dna[j][i] for j in range(len(dna)) if len(dna[j]) > i and j != i]\n        counts = [kth_nucs.count(nuc)+1 for nuc in mat_rows]\n        sum_counts = sum(counts)\n        probs = [count/sum_counts if sum_counts != 0 else 0 for count in counts]\n        for j in range(len(probs)):\n            profile[j].append(probs[j])",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "probability",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "def probability(kmer,profile):\n    #profile is a 4xk matrix\n    mat_rows = ['A','C','G','T']\n    prob_n = 1\n    for i in range(len(kmer)):\n        prob_n *= profile[mat_rows.index(kmer[i])][i]\n    return prob_n\ndef profile_most_probable_kmer(dna,profile,k):\n    #profile is a 4xk matrix\n    max_prob = 0",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "profile_most_probable_kmer",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "def profile_most_probable_kmer(dna,profile,k):\n    #profile is a 4xk matrix\n    max_prob = 0\n    max_kmer = ''\n    for i in range(len(dna)-k+1):\n        kmer = dna[i:i+k]\n        prob = probability(kmer,profile)\n        if prob > max_prob or max_kmer == '':\n            max_prob = prob\n            max_kmer = kmer",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "profile_random_kmer",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "def profile_random_kmer(dna,profile,k):\n\t# profile is a 4xk matrix\n\tprobs = []\n\tfor i in range(len(dna)-k+1):\n\t\tkmer = dna[i:i+k]\n\t\tprobs.append(probability(kmer,profile))\n\trandom_i = random_gibbs(probs)\n\treturn dna[random_i:random_i+k]\ndef random_gibbs(p):\n\tc = sum(p)",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "random_gibbs",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "def random_gibbs(p):\n\tc = sum(p)\n\tp = [x/c for x in p]\n\t# print(p)\n\tr = random.random()\n\t# print(r)\n\t# return the index of the integer in p which is closest to r without going over\n\tfor i in range(len(p)):\n\t\t# print(p[i])\n\t\tif r < p[i]:",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "gibbs_sampler",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "def gibbs_sampler(dna, k, t, n):\n\tmotifs = []\n\tfor i in range(t):\n\t\tstart = random.randint(0,len(dna[i])-k)\n\t\tmotifs.append(dna[i][start:start+k])\n\tbest_motifs = motifs\n\tfor j in range(n):\n\t\ti = int(random.random()*t)\n\t\tprofile = make_profile_laplace_gibbs(motifs,k,0,i)\n\t\tmotifs[i] = profile_random_kmer(dna[i],profile,k)",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.extend(['..','..','data'])\n\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba2g.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba2g.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tk,t,N = [int(x) for x in f.readline().strip().split()]\n\t\t\tdna = [line.strip() for line in f.readlines()]\nimport random\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\tpath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\tpath = os.path.join(datapath,'rosalind_ba2g.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tk,t,N = [int(x) for x in f.readline().strip().split()]\n\t\t\tdna = [line.strip() for line in f.readlines()]\nimport random\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\t\t\tk,t,N",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\t\t\tk,t,N = [int(x) for x in f.readline().strip().split()]\n\t\t\tdna = [line.strip() for line in f.readlines()]\nimport random\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef score(motifs):",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\t\t\tdna",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\t\t\tdna = [line.strip() for line in f.readlines()]\nimport random\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef score(motifs):\n\tconsensus = ''",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\thamming",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef score(motifs):\n\tconsensus = ''\n\tfor i in range(len(motifs[0])):\n\t\tnucs = [motifs[j][i] for j in range(len(motifs))]\n\t\tconsensus += max(set(nucs),key=nucs.count)",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\tconsensus",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\tconsensus = ''\n\tfor i in range(len(motifs[0])):\n\t\tnucs = [motifs[j][i] for j in range(len(motifs))]\n\t\tconsensus += max(set(nucs),key=nucs.count)\n\tscore = 0\n\tfor motif in motifs:\n\t\tscore += hamming_distance(motif,consensus)\n\treturn score\ndef make_profile_laplace_gibbs(dna,k,start,i):\n    mat_rows = ['A','C','G','T']",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\t\tnucs",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\t\tnucs = [motifs[j][i] for j in range(len(motifs))]\n\t\tconsensus += max(set(nucs),key=nucs.count)\n\tscore = 0\n\tfor motif in motifs:\n\t\tscore += hamming_distance(motif,consensus)\n\treturn score\ndef make_profile_laplace_gibbs(dna,k,start,i):\n    mat_rows = ['A','C','G','T']\n    profile = [[],[],[],[]]\n    for i in range(start,start+k):",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\tscore",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\tscore = 0\n\tfor motif in motifs:\n\t\tscore += hamming_distance(motif,consensus)\n\treturn score\ndef make_profile_laplace_gibbs(dna,k,start,i):\n    mat_rows = ['A','C','G','T']\n    profile = [[],[],[],[]]\n    for i in range(start,start+k):\n        kth_nucs = [dna[j][i] for j in range(len(dna)) if len(dna[j]) > i and j != i]\n        counts = [kth_nucs.count(nuc)+1 for nuc in mat_rows]",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\tprobs",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\tprobs = []\n\tfor i in range(len(dna)-k+1):\n\t\tkmer = dna[i:i+k]\n\t\tprobs.append(probability(kmer,profile))\n\trandom_i = random_gibbs(probs)\n\treturn dna[random_i:random_i+k]\ndef random_gibbs(p):\n\tc = sum(p)\n\tp = [x/c for x in p]\n\t# print(p)",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\t\tkmer",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\t\tkmer = dna[i:i+k]\n\t\tprobs.append(probability(kmer,profile))\n\trandom_i = random_gibbs(probs)\n\treturn dna[random_i:random_i+k]\ndef random_gibbs(p):\n\tc = sum(p)\n\tp = [x/c for x in p]\n\t# print(p)\n\tr = random.random()\n\t# print(r)",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\trandom_i",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\trandom_i = random_gibbs(probs)\n\treturn dna[random_i:random_i+k]\ndef random_gibbs(p):\n\tc = sum(p)\n\tp = [x/c for x in p]\n\t# print(p)\n\tr = random.random()\n\t# print(r)\n\t# return the index of the integer in p which is closest to r without going over\n\tfor i in range(len(p)):",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\tc",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\tc = sum(p)\n\tp = [x/c for x in p]\n\t# print(p)\n\tr = random.random()\n\t# print(r)\n\t# return the index of the integer in p which is closest to r without going over\n\tfor i in range(len(p)):\n\t\t# print(p[i])\n\t\tif r < p[i]:\n\t\t\treturn i",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\tp",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\tp = [x/c for x in p]\n\t# print(p)\n\tr = random.random()\n\t# print(r)\n\t# return the index of the integer in p which is closest to r without going over\n\tfor i in range(len(p)):\n\t\t# print(p[i])\n\t\tif r < p[i]:\n\t\t\treturn i\n\t\tr -= p[i]",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\tr",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\tr = random.random()\n\t# print(r)\n\t# return the index of the integer in p which is closest to r without going over\n\tfor i in range(len(p)):\n\t\t# print(p[i])\n\t\tif r < p[i]:\n\t\t\treturn i\n\t\tr -= p[i]\ndef gibbs_sampler(dna, k, t, n):\n\tmotifs = []",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\tmotifs",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\tmotifs = []\n\tfor i in range(t):\n\t\tstart = random.randint(0,len(dna[i])-k)\n\t\tmotifs.append(dna[i][start:start+k])\n\tbest_motifs = motifs\n\tfor j in range(n):\n\t\ti = int(random.random()*t)\n\t\tprofile = make_profile_laplace_gibbs(motifs,k,0,i)\n\t\tmotifs[i] = profile_random_kmer(dna[i],profile,k)\n\t\tif score(motifs) < score(best_motifs):",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\t\tstart",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\t\tstart = random.randint(0,len(dna[i])-k)\n\t\tmotifs.append(dna[i][start:start+k])\n\tbest_motifs = motifs\n\tfor j in range(n):\n\t\ti = int(random.random()*t)\n\t\tprofile = make_profile_laplace_gibbs(motifs,k,0,i)\n\t\tmotifs[i] = profile_random_kmer(dna[i],profile,k)\n\t\tif score(motifs) < score(best_motifs):\n\t\t\tbest_motifs = motifs\n\treturn best_motifs, score(best_motifs)",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\tbest_motifs",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\tbest_motifs = motifs\n\tfor j in range(n):\n\t\ti = int(random.random()*t)\n\t\tprofile = make_profile_laplace_gibbs(motifs,k,0,i)\n\t\tmotifs[i] = profile_random_kmer(dna[i],profile,k)\n\t\tif score(motifs) < score(best_motifs):\n\t\t\tbest_motifs = motifs\n\treturn best_motifs, score(best_motifs)\nbest_m = []\nbest_s = 100000",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\t\ti",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\t\ti = int(random.random()*t)\n\t\tprofile = make_profile_laplace_gibbs(motifs,k,0,i)\n\t\tmotifs[i] = profile_random_kmer(dna[i],profile,k)\n\t\tif score(motifs) < score(best_motifs):\n\t\t\tbest_motifs = motifs\n\treturn best_motifs, score(best_motifs)\nbest_m = []\nbest_s = 100000\nfor s in range(20):\n\t# m,s = gibbs_sampler(['CGCCCCTCTCGGGGGTGTTCAGTAAACGGCCA','GGGCGAGGTATGTGTAAGTGCCAAGGTGCCAG','TAGTACCGAGACCGAAAGAAGTATACAGGCGT','TAGATCAAGTTTCAGGTGCACGTCGGTGAACC','AATCCACCAGCTCCACGTGCAATGTTGGCCTA'],8,5,100)",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\t\tprofile",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\t\tprofile = make_profile_laplace_gibbs(motifs,k,0,i)\n\t\tmotifs[i] = profile_random_kmer(dna[i],profile,k)\n\t\tif score(motifs) < score(best_motifs):\n\t\t\tbest_motifs = motifs\n\treturn best_motifs, score(best_motifs)\nbest_m = []\nbest_s = 100000\nfor s in range(20):\n\t# m,s = gibbs_sampler(['CGCCCCTCTCGGGGGTGTTCAGTAAACGGCCA','GGGCGAGGTATGTGTAAGTGCCAAGGTGCCAG','TAGTACCGAGACCGAAAGAAGTATACAGGCGT','TAGATCAAGTTTCAGGTGCACGTCGGTGAACC','AATCCACCAGCTCCACGTGCAATGTTGGCCTA'],8,5,100)\n\tm,s = gibbs_sampler(dna,k,t,N)",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\t\tmotifs[i]",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\t\tmotifs[i] = profile_random_kmer(dna[i],profile,k)\n\t\tif score(motifs) < score(best_motifs):\n\t\t\tbest_motifs = motifs\n\treturn best_motifs, score(best_motifs)\nbest_m = []\nbest_s = 100000\nfor s in range(20):\n\t# m,s = gibbs_sampler(['CGCCCCTCTCGGGGGTGTTCAGTAAACGGCCA','GGGCGAGGTATGTGTAAGTGCCAAGGTGCCAG','TAGTACCGAGACCGAAAGAAGTATACAGGCGT','TAGATCAAGTTTCAGGTGCACGTCGGTGAACC','AATCCACCAGCTCCACGTGCAATGTTGGCCTA'],8,5,100)\n\tm,s = gibbs_sampler(dna,k,t,N)\n\t# print(m)",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\t\t\tbest_motifs",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\t\t\tbest_motifs = motifs\n\treturn best_motifs, score(best_motifs)\nbest_m = []\nbest_s = 100000\nfor s in range(20):\n\t# m,s = gibbs_sampler(['CGCCCCTCTCGGGGGTGTTCAGTAAACGGCCA','GGGCGAGGTATGTGTAAGTGCCAAGGTGCCAG','TAGTACCGAGACCGAAAGAAGTATACAGGCGT','TAGATCAAGTTTCAGGTGCACGTCGGTGAACC','AATCCACCAGCTCCACGTGCAATGTTGGCCTA'],8,5,100)\n\tm,s = gibbs_sampler(dna,k,t,N)\n\t# print(m)\n\tif s < best_s:\n\t\tbest_m = m",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "best_m",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "best_m = []\nbest_s = 100000\nfor s in range(20):\n\t# m,s = gibbs_sampler(['CGCCCCTCTCGGGGGTGTTCAGTAAACGGCCA','GGGCGAGGTATGTGTAAGTGCCAAGGTGCCAG','TAGTACCGAGACCGAAAGAAGTATACAGGCGT','TAGATCAAGTTTCAGGTGCACGTCGGTGAACC','AATCCACCAGCTCCACGTGCAATGTTGGCCTA'],8,5,100)\n\tm,s = gibbs_sampler(dna,k,t,N)\n\t# print(m)\n\tif s < best_s:\n\t\tbest_m = m\n\t\tbest_s = s\nprint('\\n'.join(best_m))",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "best_s",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "best_s = 100000\nfor s in range(20):\n\t# m,s = gibbs_sampler(['CGCCCCTCTCGGGGGTGTTCAGTAAACGGCCA','GGGCGAGGTATGTGTAAGTGCCAAGGTGCCAG','TAGTACCGAGACCGAAAGAAGTATACAGGCGT','TAGATCAAGTTTCAGGTGCACGTCGGTGAACC','AATCCACCAGCTCCACGTGCAATGTTGGCCTA'],8,5,100)\n\tm,s = gibbs_sampler(dna,k,t,N)\n\t# print(m)\n\tif s < best_s:\n\t\tbest_m = m\n\t\tbest_s = s\nprint('\\n'.join(best_m))",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\tm,s",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\tm,s = gibbs_sampler(dna,k,t,N)\n\t# print(m)\n\tif s < best_s:\n\t\tbest_m = m\n\t\tbest_s = s\nprint('\\n'.join(best_m))",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\t\tbest_m",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\t\tbest_m = m\n\t\tbest_s = s\nprint('\\n'.join(best_m))",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "\t\tbest_s",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2G",
        "description": "textbook.scripts.2.BA2G",
        "peekOfCode": "\t\tbest_s = s\nprint('\\n'.join(best_m))",
        "detail": "textbook.scripts.2.BA2G",
        "documentation": {}
    },
    {
        "label": "hamming_distance",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2H",
        "description": "textbook.scripts.2.BA2H",
        "peekOfCode": "def hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef distance_btw_pattern_and_strings(pattern,dna):\n\tk = len(pattern)\n\tdistance = 0\n\tfor text in dna:",
        "detail": "textbook.scripts.2.BA2H",
        "documentation": {}
    },
    {
        "label": "distance_btw_pattern_and_strings",
        "kind": 2,
        "importPath": "textbook.scripts.2.BA2H",
        "description": "textbook.scripts.2.BA2H",
        "peekOfCode": "def distance_btw_pattern_and_strings(pattern,dna):\n\tk = len(pattern)\n\tdistance = 0\n\tfor text in dna:\n\t\thamming = 1000000000\n\t\tfor p in [text[i:i+k] for i in range(len(text)-k+1)]:\n\t\t\tif hamming > hamming_distance(pattern,p):\n\t\t\t\thamming = hamming_distance(pattern,p)\n\t\tdistance += hamming\n\treturn distance",
        "detail": "textbook.scripts.2.BA2H",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2H",
        "description": "textbook.scripts.2.BA2H",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.extend(['..','..','data'])\n\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba2h.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:",
        "detail": "textbook.scripts.2.BA2H",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2H",
        "description": "textbook.scripts.2.BA2H",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba2h.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tpattern = f.readline().strip()\n\t\t\tdna = f.readline().strip().split()\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:",
        "detail": "textbook.scripts.2.BA2H",
        "documentation": {}
    },
    {
        "label": "\tpath",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2H",
        "description": "textbook.scripts.2.BA2H",
        "peekOfCode": "\tpath = os.path.join(datapath,'rosalind_ba2h.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tpattern = f.readline().strip()\n\t\t\tdna = f.readline().strip().split()\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1",
        "detail": "textbook.scripts.2.BA2H",
        "documentation": {}
    },
    {
        "label": "\t\t\tpattern",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2H",
        "description": "textbook.scripts.2.BA2H",
        "peekOfCode": "\t\t\tpattern = f.readline().strip()\n\t\t\tdna = f.readline().strip().split()\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef distance_btw_pattern_and_strings(pattern,dna):\n\tk = len(pattern)",
        "detail": "textbook.scripts.2.BA2H",
        "documentation": {}
    },
    {
        "label": "\t\t\tdna",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2H",
        "description": "textbook.scripts.2.BA2H",
        "peekOfCode": "\t\t\tdna = f.readline().strip().split()\ndef hamming_distance(p,q):\n\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef distance_btw_pattern_and_strings(pattern,dna):\n\tk = len(pattern)\n\tdistance = 0",
        "detail": "textbook.scripts.2.BA2H",
        "documentation": {}
    },
    {
        "label": "\thamming",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2H",
        "description": "textbook.scripts.2.BA2H",
        "peekOfCode": "\thamming = 0\n\tfor i in range(len(p)):\n\t\tif p[i] != q[i]:\n\t\t\thamming += 1\n\treturn hamming\ndef distance_btw_pattern_and_strings(pattern,dna):\n\tk = len(pattern)\n\tdistance = 0\n\tfor text in dna:\n\t\thamming = 1000000000",
        "detail": "textbook.scripts.2.BA2H",
        "documentation": {}
    },
    {
        "label": "\tk",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2H",
        "description": "textbook.scripts.2.BA2H",
        "peekOfCode": "\tk = len(pattern)\n\tdistance = 0\n\tfor text in dna:\n\t\thamming = 1000000000\n\t\tfor p in [text[i:i+k] for i in range(len(text)-k+1)]:\n\t\t\tif hamming > hamming_distance(pattern,p):\n\t\t\t\thamming = hamming_distance(pattern,p)\n\t\tdistance += hamming\n\treturn distance\n# print(distance_btw_pattern_and_strings('AAA',['TTACCTTAAC','GATATCTGTC','ACGGCGTTCG','CCCTAAAGAG','CGTCAGAGGT']))",
        "detail": "textbook.scripts.2.BA2H",
        "documentation": {}
    },
    {
        "label": "\tdistance",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2H",
        "description": "textbook.scripts.2.BA2H",
        "peekOfCode": "\tdistance = 0\n\tfor text in dna:\n\t\thamming = 1000000000\n\t\tfor p in [text[i:i+k] for i in range(len(text)-k+1)]:\n\t\t\tif hamming > hamming_distance(pattern,p):\n\t\t\t\thamming = hamming_distance(pattern,p)\n\t\tdistance += hamming\n\treturn distance\n# print(distance_btw_pattern_and_strings('AAA',['TTACCTTAAC','GATATCTGTC','ACGGCGTTCG','CCCTAAAGAG','CGTCAGAGGT']))\nprint(distance_btw_pattern_and_strings(pattern,dna))",
        "detail": "textbook.scripts.2.BA2H",
        "documentation": {}
    },
    {
        "label": "\t\thamming",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2H",
        "description": "textbook.scripts.2.BA2H",
        "peekOfCode": "\t\thamming = 1000000000\n\t\tfor p in [text[i:i+k] for i in range(len(text)-k+1)]:\n\t\t\tif hamming > hamming_distance(pattern,p):\n\t\t\t\thamming = hamming_distance(pattern,p)\n\t\tdistance += hamming\n\treturn distance\n# print(distance_btw_pattern_and_strings('AAA',['TTACCTTAAC','GATATCTGTC','ACGGCGTTCG','CCCTAAAGAG','CGTCAGAGGT']))\nprint(distance_btw_pattern_and_strings(pattern,dna))",
        "detail": "textbook.scripts.2.BA2H",
        "documentation": {}
    },
    {
        "label": "\t\t\t\thamming",
        "kind": 5,
        "importPath": "textbook.scripts.2.BA2H",
        "description": "textbook.scripts.2.BA2H",
        "peekOfCode": "\t\t\t\thamming = hamming_distance(pattern,p)\n\t\tdistance += hamming\n\treturn distance\n# print(distance_btw_pattern_and_strings('AAA',['TTACCTTAAC','GATATCTGTC','ACGGCGTTCG','CCCTAAAGAG','CGTCAGAGGT']))\nprint(distance_btw_pattern_and_strings(pattern,dna))",
        "detail": "textbook.scripts.2.BA2H",
        "documentation": {}
    },
    {
        "label": "composition",
        "kind": 2,
        "importPath": "textbook.scripts.3.BA3A",
        "description": "textbook.scripts.3.BA3A",
        "peekOfCode": "def composition(text,k):\n\tkmers = [text[i:i+k] for i in range(len(text)-k+1)]\n\treturn sorted(kmers)\n# print(composition('CAATCCAAC',5))\nprint('\\n'.join(composition(text,k)))",
        "detail": "textbook.scripts.3.BA3A",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3A",
        "description": "textbook.scripts.3.BA3A",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.extend(['..','..','data'])\n\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba3a.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:",
        "detail": "textbook.scripts.3.BA3A",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3A",
        "description": "textbook.scripts.3.BA3A",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba3a.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tk = int(f.readline().strip())\n\t\t\ttext = f.readline().strip()\ndef composition(text,k):\n\tkmers = [text[i:i+k] for i in range(len(text)-k+1)]\n\treturn sorted(kmers)\n# print(composition('CAATCCAAC',5))",
        "detail": "textbook.scripts.3.BA3A",
        "documentation": {}
    },
    {
        "label": "\tpath",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3A",
        "description": "textbook.scripts.3.BA3A",
        "peekOfCode": "\tpath = os.path.join(datapath,'rosalind_ba3a.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tk = int(f.readline().strip())\n\t\t\ttext = f.readline().strip()\ndef composition(text,k):\n\tkmers = [text[i:i+k] for i in range(len(text)-k+1)]\n\treturn sorted(kmers)\n# print(composition('CAATCCAAC',5))\nprint('\\n'.join(composition(text,k)))",
        "detail": "textbook.scripts.3.BA3A",
        "documentation": {}
    },
    {
        "label": "\t\t\tk",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3A",
        "description": "textbook.scripts.3.BA3A",
        "peekOfCode": "\t\t\tk = int(f.readline().strip())\n\t\t\ttext = f.readline().strip()\ndef composition(text,k):\n\tkmers = [text[i:i+k] for i in range(len(text)-k+1)]\n\treturn sorted(kmers)\n# print(composition('CAATCCAAC',5))\nprint('\\n'.join(composition(text,k)))",
        "detail": "textbook.scripts.3.BA3A",
        "documentation": {}
    },
    {
        "label": "\t\t\ttext",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3A",
        "description": "textbook.scripts.3.BA3A",
        "peekOfCode": "\t\t\ttext = f.readline().strip()\ndef composition(text,k):\n\tkmers = [text[i:i+k] for i in range(len(text)-k+1)]\n\treturn sorted(kmers)\n# print(composition('CAATCCAAC',5))\nprint('\\n'.join(composition(text,k)))",
        "detail": "textbook.scripts.3.BA3A",
        "documentation": {}
    },
    {
        "label": "\tkmers",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3A",
        "description": "textbook.scripts.3.BA3A",
        "peekOfCode": "\tkmers = [text[i:i+k] for i in range(len(text)-k+1)]\n\treturn sorted(kmers)\n# print(composition('CAATCCAAC',5))\nprint('\\n'.join(composition(text,k)))",
        "detail": "textbook.scripts.3.BA3A",
        "documentation": {}
    },
    {
        "label": "genome_path",
        "kind": 2,
        "importPath": "textbook.scripts.3.BA3B",
        "description": "textbook.scripts.3.BA3B",
        "peekOfCode": "def genome_path(kmers):\n\ttext = kmers[0]\n\tfor kmer in kmers[1:]:\n\t\ttext += kmer[-1]\n\treturn text\n# print(genome_path(['ACCGA','CCGAA','CGAAG','GAAGC','AAGCT']))\nprint(genome_path(kmers))",
        "detail": "textbook.scripts.3.BA3B",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3B",
        "description": "textbook.scripts.3.BA3B",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.extend(['..','..','data'])\n\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba3b.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:",
        "detail": "textbook.scripts.3.BA3B",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3B",
        "description": "textbook.scripts.3.BA3B",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba3b.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tkmers = [line.strip() for line in f.readlines()]\ndef genome_path(kmers):\n\ttext = kmers[0]\n\tfor kmer in kmers[1:]:\n\t\ttext += kmer[-1]\n\treturn text",
        "detail": "textbook.scripts.3.BA3B",
        "documentation": {}
    },
    {
        "label": "\tpath",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3B",
        "description": "textbook.scripts.3.BA3B",
        "peekOfCode": "\tpath = os.path.join(datapath,'rosalind_ba3b.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tkmers = [line.strip() for line in f.readlines()]\ndef genome_path(kmers):\n\ttext = kmers[0]\n\tfor kmer in kmers[1:]:\n\t\ttext += kmer[-1]\n\treturn text\n# print(genome_path(['ACCGA','CCGAA','CGAAG','GAAGC','AAGCT']))",
        "detail": "textbook.scripts.3.BA3B",
        "documentation": {}
    },
    {
        "label": "\t\t\tkmers",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3B",
        "description": "textbook.scripts.3.BA3B",
        "peekOfCode": "\t\t\tkmers = [line.strip() for line in f.readlines()]\ndef genome_path(kmers):\n\ttext = kmers[0]\n\tfor kmer in kmers[1:]:\n\t\ttext += kmer[-1]\n\treturn text\n# print(genome_path(['ACCGA','CCGAA','CGAAG','GAAGC','AAGCT']))\nprint(genome_path(kmers))",
        "detail": "textbook.scripts.3.BA3B",
        "documentation": {}
    },
    {
        "label": "\ttext",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3B",
        "description": "textbook.scripts.3.BA3B",
        "peekOfCode": "\ttext = kmers[0]\n\tfor kmer in kmers[1:]:\n\t\ttext += kmer[-1]\n\treturn text\n# print(genome_path(['ACCGA','CCGAA','CGAAG','GAAGC','AAGCT']))\nprint(genome_path(kmers))",
        "detail": "textbook.scripts.3.BA3B",
        "documentation": {}
    },
    {
        "label": "overlap_graph",
        "kind": 2,
        "importPath": "textbook.scripts.3.BA3C",
        "description": "textbook.scripts.3.BA3C",
        "peekOfCode": "def overlap_graph(patterns):\n\tadjacency_list = []\n\tfor pattern in patterns:\n\t\tfor pattern2 in patterns:\n\t\t\tif pattern[1:] == pattern2[:-1]:\n\t\t\t\tadjacency_list.append(pattern + ' -> ' + pattern2)\n\treturn adjacency_list\n# print('\\n'.join(overlap_graph(['ATGCG','GCATG','CATGC','AGGCA','GGCAT'])))\nprint('\\n'.join(overlap_graph(patterns)))",
        "detail": "textbook.scripts.3.BA3C",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3C",
        "description": "textbook.scripts.3.BA3C",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.extend(['..','..','data'])\n\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba3c.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:",
        "detail": "textbook.scripts.3.BA3C",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3C",
        "description": "textbook.scripts.3.BA3C",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba3c.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tpatterns = [line.strip() for line in f.readlines()]\ndef overlap_graph(patterns):\n\tadjacency_list = []\n\tfor pattern in patterns:\n\t\tfor pattern2 in patterns:\n\t\t\tif pattern[1:] == pattern2[:-1]:",
        "detail": "textbook.scripts.3.BA3C",
        "documentation": {}
    },
    {
        "label": "\tpath",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3C",
        "description": "textbook.scripts.3.BA3C",
        "peekOfCode": "\tpath = os.path.join(datapath,'rosalind_ba3c.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tpatterns = [line.strip() for line in f.readlines()]\ndef overlap_graph(patterns):\n\tadjacency_list = []\n\tfor pattern in patterns:\n\t\tfor pattern2 in patterns:\n\t\t\tif pattern[1:] == pattern2[:-1]:\n\t\t\t\tadjacency_list.append(pattern + ' -> ' + pattern2)",
        "detail": "textbook.scripts.3.BA3C",
        "documentation": {}
    },
    {
        "label": "\t\t\tpatterns",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3C",
        "description": "textbook.scripts.3.BA3C",
        "peekOfCode": "\t\t\tpatterns = [line.strip() for line in f.readlines()]\ndef overlap_graph(patterns):\n\tadjacency_list = []\n\tfor pattern in patterns:\n\t\tfor pattern2 in patterns:\n\t\t\tif pattern[1:] == pattern2[:-1]:\n\t\t\t\tadjacency_list.append(pattern + ' -> ' + pattern2)\n\treturn adjacency_list\n# print('\\n'.join(overlap_graph(['ATGCG','GCATG','CATGC','AGGCA','GGCAT'])))\nprint('\\n'.join(overlap_graph(patterns)))",
        "detail": "textbook.scripts.3.BA3C",
        "documentation": {}
    },
    {
        "label": "\tadjacency_list",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3C",
        "description": "textbook.scripts.3.BA3C",
        "peekOfCode": "\tadjacency_list = []\n\tfor pattern in patterns:\n\t\tfor pattern2 in patterns:\n\t\t\tif pattern[1:] == pattern2[:-1]:\n\t\t\t\tadjacency_list.append(pattern + ' -> ' + pattern2)\n\treturn adjacency_list\n# print('\\n'.join(overlap_graph(['ATGCG','GCATG','CATGC','AGGCA','GGCAT'])))\nprint('\\n'.join(overlap_graph(patterns)))",
        "detail": "textbook.scripts.3.BA3C",
        "documentation": {}
    },
    {
        "label": "debruijn_graph",
        "kind": 2,
        "importPath": "textbook.scripts.3.BA3D",
        "description": "textbook.scripts.3.BA3D",
        "peekOfCode": "def debruijn_graph(text,k):\n\t# make a dictionary for edges in a directed graph, using the starting node as the key and the ending node as the value\n\t# edges = set([text[i:i+k-1] for i in range(len(text)-k+2)])\n\tedges = {node:[] for node in list(set([text[i:i+k-1] for i in range(len(text)-k+2)]))}\n\t# print(edges)\n\t# iterate through text, adding edges between nodes. A single node can connect to multiple nodes, which are delimited by commas\n\tfor i in range(len(text)-k+1):\n\t\tedges[text[i:i+k-1]].append(text[i+1:i+k])\n\t# create print format of adjacency list\n\tadjacency_list = []",
        "detail": "textbook.scripts.3.BA3D",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3D",
        "description": "textbook.scripts.3.BA3D",
        "peekOfCode": "\tdatapath = []\n\tif 'textbook' in glob.glob('*'):\n\t\tdatapath.append('textbook')\n\t\tdatapath.append('data')\n\telif len(glob.glob('*.py')) > 0:\n\t\tdatapath.extend(['..','..','data'])\n\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba3d.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:",
        "detail": "textbook.scripts.3.BA3D",
        "documentation": {}
    },
    {
        "label": "\tdatapath",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3D",
        "description": "textbook.scripts.3.BA3D",
        "peekOfCode": "\tdatapath = os.path.join(*datapath)\n\tpath = os.path.join(datapath,'rosalind_ba3d.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tk = int(f.readline().strip())\n\t\t\ttext = f.readline().strip()\ndef debruijn_graph(text,k):\n\t# make a dictionary for edges in a directed graph, using the starting node as the key and the ending node as the value\n\t# edges = set([text[i:i+k-1] for i in range(len(text)-k+2)])\n\tedges = {node:[] for node in list(set([text[i:i+k-1] for i in range(len(text)-k+2)]))}",
        "detail": "textbook.scripts.3.BA3D",
        "documentation": {}
    },
    {
        "label": "\tpath",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3D",
        "description": "textbook.scripts.3.BA3D",
        "peekOfCode": "\tpath = os.path.join(datapath,'rosalind_ba3d.txt')\n\tif os.path.exists(path):\n\t\twith open(path) as f:\n\t\t\tk = int(f.readline().strip())\n\t\t\ttext = f.readline().strip()\ndef debruijn_graph(text,k):\n\t# make a dictionary for edges in a directed graph, using the starting node as the key and the ending node as the value\n\t# edges = set([text[i:i+k-1] for i in range(len(text)-k+2)])\n\tedges = {node:[] for node in list(set([text[i:i+k-1] for i in range(len(text)-k+2)]))}\n\t# print(edges)",
        "detail": "textbook.scripts.3.BA3D",
        "documentation": {}
    },
    {
        "label": "\t\t\tk",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3D",
        "description": "textbook.scripts.3.BA3D",
        "peekOfCode": "\t\t\tk = int(f.readline().strip())\n\t\t\ttext = f.readline().strip()\ndef debruijn_graph(text,k):\n\t# make a dictionary for edges in a directed graph, using the starting node as the key and the ending node as the value\n\t# edges = set([text[i:i+k-1] for i in range(len(text)-k+2)])\n\tedges = {node:[] for node in list(set([text[i:i+k-1] for i in range(len(text)-k+2)]))}\n\t# print(edges)\n\t# iterate through text, adding edges between nodes. A single node can connect to multiple nodes, which are delimited by commas\n\tfor i in range(len(text)-k+1):\n\t\tedges[text[i:i+k-1]].append(text[i+1:i+k])",
        "detail": "textbook.scripts.3.BA3D",
        "documentation": {}
    },
    {
        "label": "\t\t\ttext",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3D",
        "description": "textbook.scripts.3.BA3D",
        "peekOfCode": "\t\t\ttext = f.readline().strip()\ndef debruijn_graph(text,k):\n\t# make a dictionary for edges in a directed graph, using the starting node as the key and the ending node as the value\n\t# edges = set([text[i:i+k-1] for i in range(len(text)-k+2)])\n\tedges = {node:[] for node in list(set([text[i:i+k-1] for i in range(len(text)-k+2)]))}\n\t# print(edges)\n\t# iterate through text, adding edges between nodes. A single node can connect to multiple nodes, which are delimited by commas\n\tfor i in range(len(text)-k+1):\n\t\tedges[text[i:i+k-1]].append(text[i+1:i+k])\n\t# create print format of adjacency list",
        "detail": "textbook.scripts.3.BA3D",
        "documentation": {}
    },
    {
        "label": "\tedges",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3D",
        "description": "textbook.scripts.3.BA3D",
        "peekOfCode": "\tedges = {node:[] for node in list(set([text[i:i+k-1] for i in range(len(text)-k+2)]))}\n\t# print(edges)\n\t# iterate through text, adding edges between nodes. A single node can connect to multiple nodes, which are delimited by commas\n\tfor i in range(len(text)-k+1):\n\t\tedges[text[i:i+k-1]].append(text[i+1:i+k])\n\t# create print format of adjacency list\n\tadjacency_list = []\n\tfor node in edges:\n\t\tif len(edges[node]) > 0:\n\t\t\tadjacency_list.append(node + ' -> ' + ','.join(edges[node]))",
        "detail": "textbook.scripts.3.BA3D",
        "documentation": {}
    },
    {
        "label": "\tadjacency_list",
        "kind": 5,
        "importPath": "textbook.scripts.3.BA3D",
        "description": "textbook.scripts.3.BA3D",
        "peekOfCode": "\tadjacency_list = []\n\tfor node in edges:\n\t\tif len(edges[node]) > 0:\n\t\t\tadjacency_list.append(node + ' -> ' + ','.join(edges[node]))\n\treturn adjacency_list\n# print('\\n'.join(debruijn_graph('AAGATTCTCTAC',4)))\n# print('\\n'.join(debruijn_graph(text,k)))\n# write to output file\nwith open(os.path.join(datapath,'rosalind_ba3d_output.txt'),'w') as outputfile:\n\toutputfile.write('\\n'.join(debruijn_graph(text,k)))",
        "detail": "textbook.scripts.3.BA3D",
        "documentation": {}
    },
    {
        "label": "debruijn_from_kmers",
        "kind": 2,
        "importPath": "textbook.scripts.3.BA3E",
        "description": "textbook.scripts.3.BA3E",
        "peekOfCode": "def debruijn_from_kmers(patterns):\n    # given a collection of k-mers, the nodes are simply all unique (k-1)-mers that are a prefix or suffix of any k-mer\n    k = len(patterns[0]) - 1\n    nodes = set()\n    for p in patterns:\n        nodes.add(p[1:])\n        nodes.add(p[:k])\n    # for every k-mer, we connect the prefix node and suffix node by a directed edge\n    edges = {node: [] for node in nodes}\n    for p in patterns:",
        "detail": "textbook.scripts.3.BA3E",
        "documentation": {}
    },
    {
        "label": "read_graph",
        "kind": 2,
        "importPath": "textbook.scripts.3.BA3F",
        "description": "textbook.scripts.3.BA3F",
        "peekOfCode": "def read_graph(adjacency_list):\n    graph = {}\n    for g in adjacency_list:\n        node_a, _, nodes_b = g.split(\" \")\n        graph[node_a] = nodes_b.split(\",\")\n    return graph\ndef random_walk(graph, start_node):\n    curr = start_node\n    next = random.choice(graph[curr])\n    cycle = [(curr, next)]",
        "detail": "textbook.scripts.3.BA3F",
        "documentation": {}
    },
    {
        "label": "random_walk",
        "kind": 2,
        "importPath": "textbook.scripts.3.BA3F",
        "description": "textbook.scripts.3.BA3F",
        "peekOfCode": "def random_walk(graph, start_node):\n    curr = start_node\n    next = random.choice(graph[curr])\n    cycle = [(curr, next)]\n    remaining_graph = remove_edge(graph, (curr, next))\n    while start_node != next:\n        curr = next\n        next = random.choice(remaining_graph[curr])\n        remaining_graph = remove_edge(remaining_graph, (curr, next))\n        cycle.append((curr, next))",
        "detail": "textbook.scripts.3.BA3F",
        "documentation": {}
    },
    {
        "label": "remove_edge",
        "kind": 2,
        "importPath": "textbook.scripts.3.BA3F",
        "description": "textbook.scripts.3.BA3F",
        "peekOfCode": "def remove_edge(graph, edge):\n    if len(graph[edge[0]]) <= 1:\n        del graph[edge[0]]\n    else:\n        edges = graph[edge[0]]\n        edges.remove(edge[1])\n        graph[edge[0]] = edges\n    return graph\ndef eulerian_cycle(adjacency_list):\n    #  form a cycle Cycle by randomly walking in Graph (don't visit the same edge twice!)",
        "detail": "textbook.scripts.3.BA3F",
        "documentation": {}
    },
    {
        "label": "eulerian_cycle",
        "kind": 2,
        "importPath": "textbook.scripts.3.BA3F",
        "description": "textbook.scripts.3.BA3F",
        "peekOfCode": "def eulerian_cycle(adjacency_list):\n    #  form a cycle Cycle by randomly walking in Graph (don't visit the same edge twice!)\n    # while there are unexplored edges in Graph\n    # \tselect a node newStart in Cycle with still unexplored edges\n    # \tform Cycle’ by traversing Cycle (starting at newStart) and then randomly walking\n    # \tCycle ← Cycle’\n    # return Cycle\n    graph = read_graph(adjacency_list)\n    all_edges = set()\n    for node_a, node_b in graph.items():",
        "detail": "textbook.scripts.3.BA3F",
        "documentation": {}
    }
]